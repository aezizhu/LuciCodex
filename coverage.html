
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>lucicodex: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/aezizhu/LuciCodex/cmd/lucicodex/main.go (6.9%)</option>
				
				<option value="file1">github.com/aezizhu/LuciCodex/internal/auth/store.go (88.1%)</option>
				
				<option value="file2">github.com/aezizhu/LuciCodex/internal/config/config.go (61.4%)</option>
				
				<option value="file3">github.com/aezizhu/LuciCodex/internal/executor/executor.go (94.6%)</option>
				
				<option value="file4">github.com/aezizhu/LuciCodex/internal/executor/fields.go (84.6%)</option>
				
				<option value="file5">github.com/aezizhu/LuciCodex/internal/llm/anthropic.go (2.9%)</option>
				
				<option value="file6">github.com/aezizhu/LuciCodex/internal/llm/gemini.go (91.7%)</option>
				
				<option value="file7">github.com/aezizhu/LuciCodex/internal/llm/http_client.go (25.0%)</option>
				
				<option value="file8">github.com/aezizhu/LuciCodex/internal/llm/openai.go (2.9%)</option>
				
				<option value="file9">github.com/aezizhu/LuciCodex/internal/llm/provider.go (0.0%)</option>
				
				<option value="file10">github.com/aezizhu/LuciCodex/internal/logging/logger.go (87.5%)</option>
				
				<option value="file11">github.com/aezizhu/LuciCodex/internal/metrics/collector.go (92.8%)</option>
				
				<option value="file12">github.com/aezizhu/LuciCodex/internal/openwrt/facts.go (71.0%)</option>
				
				<option value="file13">github.com/aezizhu/LuciCodex/internal/plan/plan.go (100.0%)</option>
				
				<option value="file14">github.com/aezizhu/LuciCodex/internal/plugins/plugin.go (71.3%)</option>
				
				<option value="file15">github.com/aezizhu/LuciCodex/internal/policy/policy.go (86.7%)</option>
				
				<option value="file16">github.com/aezizhu/LuciCodex/internal/repl/repl.go (63.8%)</option>
				
				<option value="file17">github.com/aezizhu/LuciCodex/internal/security/sandbox.go (60.7%)</option>
				
				<option value="file18">github.com/aezizhu/LuciCodex/internal/testutil/testutil.go (0.0%)</option>
				
				<option value="file19">github.com/aezizhu/LuciCodex/internal/ui/json.go (100.0%)</option>
				
				<option value="file20">github.com/aezizhu/LuciCodex/internal/ui/ui.go (96.8%)</option>
				
				<option value="file21">github.com/aezizhu/LuciCodex/internal/wizard/setup.go (78.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "bufio"
        "context"
        "flag"
        "fmt"
        "os"
        "os/signal"
        "strings"
        "syscall"
        "time"

        "github.com/aezizhu/LuciCodex/internal/config"
        "github.com/aezizhu/LuciCodex/internal/executor"
        "github.com/aezizhu/LuciCodex/internal/llm"
        "github.com/aezizhu/LuciCodex/internal/logging"
        "github.com/aezizhu/LuciCodex/internal/openwrt"
        "github.com/aezizhu/LuciCodex/internal/plan"
        "github.com/aezizhu/LuciCodex/internal/policy"
        "github.com/aezizhu/LuciCodex/internal/repl"
        "github.com/aezizhu/LuciCodex/internal/ui"
        "github.com/aezizhu/LuciCodex/internal/wizard"
)

const version = "0.4.33"

func acquireLock() (*os.File, string, error) <span class="cov1" title="1">{
        lockPaths := []string{"/var/lock/lucicodex.lock", "/tmp/lucicodex.lock"}
        var lastErr error

        for i, lockPath := range lockPaths </span><span class="cov6" title="2">{
                f, err := os.OpenFile(lockPath, os.O_CREATE|os.O_EXCL|os.O_WRONLY, 0600)
                if err == nil </span><span class="cov1" title="1">{
                        if i &gt; 0 </span><span class="cov1" title="1">{
                                fmt.Fprintf(os.Stderr, "Note: falling back to %s\n", lockPath)
                        }</span>
                        <span class="cov1" title="1">return f, lockPath, nil</span>
                }
                <span class="cov1" title="1">lastErr = err
                if os.IsExist(err) </span><span class="cov0" title="0">{
                        return nil, "", fmt.Errorf("execution in progress (lock file exists: %s)", lockPath)
                }</span>
        }

        <span class="cov0" title="0">return nil, "", fmt.Errorf("failed to acquire lock: %w", lastErr)</span>
}

func releaseLock(f *os.File) <span class="cov10" title="3">{
        if f != nil </span><span class="cov6" title="2">{
                name := f.Name()
                f.Close()
                os.Remove(name)
        }</span>
}

func main() <span class="cov0" title="0">{
        var (
                configPath  = flag.String("config", "", "path to JSON config file")
                model       = flag.String("model", "", "model name")
                provider    = flag.String("provider", "", "provider name (gemini, openai, anthropic)")
                dryRun      = flag.Bool("dry-run", true, "only print plan, do not execute")
                approve     = flag.Bool("approve", false, "auto-approve plan without confirmation")
                confirmEach = flag.Bool("confirm-each", false, "confirm each command before execution")
                timeout     = flag.Int("timeout", 0, "per-command timeout in seconds")
                maxCommands = flag.Int("max-commands", 0, "maximum number of commands to execute")
                maxRetries  = flag.Int("max-retries", -1, "maximum retry attempts for failed commands (-1 = use config)")
                autoRetry   = flag.Bool("auto-retry", true, "automatically retry failed commands with AI-generated fixes")
                logFile     = flag.String("log-file", "", "log file path")
                showVersion = flag.Bool("version", false, "print version and exit")
                jsonOutput  = flag.Bool("json", false, "emit JSON output for plan and results")
                facts       = flag.Bool("facts", true, "include environment facts in prompt")
                interactive = flag.Bool("interactive", false, "start interactive REPL mode")
                setup       = flag.Bool("setup", false, "run setup wizard")
                joinArgs    = flag.Bool("join-args", false, "join all arguments into single prompt (experimental)")
        )

        flag.Parse()

        if *showVersion </span><span class="cov0" title="0">{
                fmt.Printf("LuciCodex version %s\n", version)
                os.Exit(0)
        }</span>

        <span class="cov0" title="0">cfg, err := config.Load(*configPath)
        if err != nil </span><span class="cov0" title="0">{
                if !*setup </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Configuration error: %v\n", err)
                        fmt.Fprintf(os.Stderr, "Run with -setup to configure LuciCodex\n")
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">cfg = config.Config{}</span>
        }

        <span class="cov0" title="0">if *model != "" </span><span class="cov0" title="0">{
                cfg.Model = *model
        }</span>
        <span class="cov0" title="0">if *provider != "" </span><span class="cov0" title="0">{
                cfg.Provider = *provider
        }</span>
        <span class="cov0" title="0">if *timeout &gt; 0 </span><span class="cov0" title="0">{
                cfg.TimeoutSeconds = *timeout
        }</span>
        <span class="cov0" title="0">if *maxCommands &gt; 0 </span><span class="cov0" title="0">{
                cfg.MaxCommands = *maxCommands
        }</span>
        <span class="cov0" title="0">if *maxRetries &gt;= 0 </span><span class="cov0" title="0">{
                cfg.MaxRetries = *maxRetries
        }</span>
        <span class="cov0" title="0">if *logFile != "" </span><span class="cov0" title="0">{
                cfg.LogFile = *logFile
        }</span>
        <span class="cov0" title="0">cfg.DryRun = *dryRun
        cfg.AutoApprove = *approve
        cfg.AutoRetry = *autoRetry

        // Re-apply provider settings after CLI flag overrides
        // This ensures -provider=openai correctly sets OpenAI endpoint/model
        cfg.ApplyProviderSettings()

        if !*confirmEach &amp;&amp; cfg.ConfirmEach </span><span class="cov0" title="0">{
                *confirmEach = true
        }</span>

        <span class="cov0" title="0">if *setup </span><span class="cov0" title="0">{
                w := wizard.New(os.Stdin, os.Stdout)
                if err := w.Run(); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Setup error: %v\n", err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">os.Exit(0)</span>
        }

        <span class="cov0" title="0">if *interactive </span><span class="cov0" title="0">{
                r := repl.New(cfg, os.Stdin, os.Stdout)
                ctx := context.Background()
                if err := r.Run(ctx); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "REPL error: %v\n", err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">os.Exit(0)</span>
        }

        <span class="cov0" title="0">args := flag.Args()
        if len(args) == 0 </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Usage: lucicodex [flags] &lt;prompt&gt;\n")
                fmt.Fprintf(os.Stderr, "Run 'lucicodex -h' for help\n")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">var prompt string
        if *joinArgs </span><span class="cov0" title="0">{
                prompt = strings.Join(args, " ")
        }</span> else<span class="cov0" title="0"> {
                prompt = args[0]
        }</span>
        <span class="cov0" title="0">ctx := context.Background()

        llmProvider := llm.NewProvider(cfg)
        policyEngine := policy.New(cfg)
        execEngine := executor.New(cfg)
        logger := logging.New(cfg.LogFile)

        instruction := plan.BuildInstructionWithLimit(cfg.MaxCommands)
        if *facts </span><span class="cov0" title="0">{
                factsCtx, cancel := context.WithTimeout(ctx, 3*time.Second)
                defer cancel()
                envFacts := openwrt.CollectFacts(factsCtx)
                if envFacts != "" </span><span class="cov0" title="0">{
                        instruction += "\n\nEnvironment facts (read-only):\n" + envFacts
                }</span>
        }

        <span class="cov0" title="0">fullPrompt := instruction + "\n\nUser request: " + prompt

        // Generate plan
        planCtx, cancel := context.WithTimeout(ctx, 60*time.Second)
        defer cancel()

        p, err := llmProvider.GeneratePlan(planCtx, fullPrompt)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "LLM error: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if len(p.Commands) == 0 </span><span class="cov0" title="0">{
                fmt.Println("No commands proposed.")
                os.Exit(0)
        }</span>

        <span class="cov0" title="0">if cfg.MaxCommands &gt; 0 &amp;&amp; len(p.Commands) &gt; cfg.MaxCommands </span><span class="cov0" title="0">{
                p.Commands = p.Commands[:cfg.MaxCommands]
        }</span>

        // Validate plan
        <span class="cov0" title="0">if err := policyEngine.ValidatePlan(p); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Plan rejected by policy: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if *jsonOutput </span><span class="cov0" title="0">{
                if err := ui.PrintPlanJSON(os.Stdout, p); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "JSON output error: %v\n", err)
                        os.Exit(1)
                }</span>
        } else<span class="cov0" title="0"> {
                ui.PrintPlan(os.Stdout, p)
        }</span>

        <span class="cov0" title="0">logger.Plan(prompt, p)

        if cfg.DryRun </span><span class="cov0" title="0">{
                if !*jsonOutput </span><span class="cov0" title="0">{
                        fmt.Println("\nDry run mode - no execution")
                }</span>
                <span class="cov0" title="0">os.Exit(0)</span>
        }

        <span class="cov0" title="0">if !cfg.AutoApprove </span><span class="cov0" title="0">{
                reader := bufio.NewReader(os.Stdin)
                ok, err := ui.Confirm(reader, os.Stdout, "Execute these commands?")
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Confirmation error: %v\n", err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">if !ok </span><span class="cov0" title="0">{
                        fmt.Println("Cancelled")
                        os.Exit(0)
                }</span>
        }

        <span class="cov0" title="0">lockFile, lockPath, err := acquireLock()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer releaseLock(lockFile)

        fmt.Fprintf(os.Stderr, "Acquired execution lock: %s\n", lockPath)

        sigc := make(chan os.Signal, 1)
        signal.Notify(sigc, os.Interrupt, syscall.SIGTERM)
        go func() </span><span class="cov0" title="0">{
                &lt;-sigc
                releaseLock(lockFile)
                os.Exit(1)
        }</span>()

        <span class="cov0" title="0">var results executor.Results
        if *confirmEach </span><span class="cov0" title="0">{
                reader := bufio.NewReader(os.Stdin)
                for i, cmd := range p.Commands </span><span class="cov0" title="0">{
                        fmt.Printf("\nExecute command %d: %s\n", i+1, executor.FormatCommand(cmd.Command))
                        ok, err := ui.Confirm(reader, os.Stdout, "Proceed?")
                        if err != nil || !ok </span><span class="cov0" title="0">{
                                fmt.Println("Skipped")
                                continue</span>
                        }
                        <span class="cov0" title="0">result := execEngine.RunCommand(ctx, i, cmd)
                        results.Items = append(results.Items, result)
                        if result.Err != nil </span><span class="cov0" title="0">{
                                results.Failed++
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                results = execEngine.RunPlan(ctx, p)
        }</span>

        // Retry logic for failed commands
        <span class="cov0" title="0">if cfg.AutoRetry &amp;&amp; results.Failed &gt; 0 &amp;&amp; cfg.MaxRetries &gt; 0 </span><span class="cov0" title="0">{
                for retryAttempt := 1; retryAttempt &lt;= cfg.MaxRetries; retryAttempt++ </span><span class="cov0" title="0">{
                        // Find first failed command
                        var failedResult *executor.Result
                        for i := range results.Items </span><span class="cov0" title="0">{
                                if results.Items[i].Err != nil </span><span class="cov0" title="0">{
                                        failedResult = &amp;results.Items[i]
                                        break</span>
                                }
                        }

                        <span class="cov0" title="0">if failedResult == nil </span><span class="cov0" title="0">{
                                break</span> // No more failures
                        }

                        <span class="cov0" title="0">if !*jsonOutput </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "\n??  Command failed: %s\n", executor.FormatCommand(failedResult.Command))
                                fmt.Fprintf(os.Stderr, "Error: %v\n", failedResult.Err)
                                fmt.Fprintf(os.Stderr, "Output: %s\n", failedResult.Output)
                                fmt.Fprintf(os.Stderr, "?? Attempting automatic fix (attempt %d/%d)...\n", retryAttempt, cfg.MaxRetries)
                        }</span>

                        // Generate fix plan
                        <span class="cov0" title="0">fixCtx, fixCancel := context.WithTimeout(ctx, 30*time.Second)
                        fixPlan, err := llmProvider.GenerateErrorFix(fixCtx,
                                executor.FormatCommand(failedResult.Command),
                                failedResult.Output,
                                retryAttempt)
                        fixCancel()

                        if err != nil </span><span class="cov0" title="0">{
                                if !*jsonOutput </span><span class="cov0" title="0">{
                                        fmt.Fprintf(os.Stderr, "Failed to generate fix: %v\n", err)
                                }</span>
                                <span class="cov0" title="0">break</span>
                        }

                        <span class="cov0" title="0">if len(fixPlan.Commands) == 0 </span><span class="cov0" title="0">{
                                if !*jsonOutput </span><span class="cov0" title="0">{
                                        fmt.Fprintf(os.Stderr, "No fix commands generated\n")
                                }</span>
                                <span class="cov0" title="0">break</span>
                        }

                        // Validate fix plan
                        <span class="cov0" title="0">if err := policyEngine.ValidatePlan(fixPlan); err != nil </span><span class="cov0" title="0">{
                                if !*jsonOutput </span><span class="cov0" title="0">{
                                        fmt.Fprintf(os.Stderr, "Fix plan rejected by policy: %v\n", err)
                                }</span>
                                <span class="cov0" title="0">break</span>
                        }

                        <span class="cov0" title="0">if !*jsonOutput </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "\n?? Fix plan: %s\n", fixPlan.Summary)
                                for _, cmd := range fixPlan.Commands </span><span class="cov0" title="0">{
                                        fmt.Fprintf(os.Stderr, "  ? %s\n", executor.FormatCommand(cmd.Command))
                                }</span>
                        }

                        // Execute fix
                        <span class="cov0" title="0">fixResults := execEngine.RunPlan(ctx, fixPlan)

                        // Mark original failure as retried by removing the error if fix succeeded
                        if fixResults.Failed == 0 </span><span class="cov0" title="0">{
                                if !*jsonOutput </span><span class="cov0" title="0">{
                                        fmt.Fprintf(os.Stderr, "? Fix successful!\n")
                                }</span>
                                <span class="cov0" title="0">failedResult.Err = nil
                                results.Failed--

                                // Append fix results to overall results
                                for _, fr := range fixResults.Items </span><span class="cov0" title="0">{
                                        results.Items = append(results.Items, fr)
                                }</span>
                                <span class="cov0" title="0">break</span>
                        } else<span class="cov0" title="0"> {
                                if !*jsonOutput </span><span class="cov0" title="0">{
                                        fmt.Fprintf(os.Stderr, "? Fix attempt failed\n")
                                }</span>
                                // Update the failed result with the new error
                                <span class="cov0" title="0">for _, fr := range fixResults.Items </span><span class="cov0" title="0">{
                                        if fr.Err != nil </span><span class="cov0" title="0">{
                                                failedResult.Output = fr.Output
                                                failedResult.Err = fr.Err
                                                break</span>
                                        }
                                }
                        }
                }
        }

        <span class="cov0" title="0">if *jsonOutput </span><span class="cov0" title="0">{
                if err := ui.PrintResultsJSON(os.Stdout, results); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "JSON output error: %v\n", err)
                        os.Exit(1)
                }</span>
        } else<span class="cov0" title="0"> {
                ui.PrintResults(os.Stdout, results)
        }</span>

        <span class="cov0" title="0">items := make([]logging.ResultItem, 0, len(results.Items))
        for _, it := range results.Items </span><span class="cov0" title="0">{
                errStr := ""
                if it.Err != nil </span><span class="cov0" title="0">{
                        errStr = it.Err.Error()
                }</span>
                <span class="cov0" title="0">items = append(items, logging.ResultItem{
                        Index:   it.Index,
                        Command: it.Command,
                        Output:  it.Output,
                        Error:   errStr,
                        Elapsed: it.Elapsed,
                })</span>
        }
        <span class="cov0" title="0">logger.Results(items)

        if results.Failed &gt; 0 </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package auth

import (
    "encoding/json"
    "errors"
    "os"
    "path/filepath"
    "sync"
    "time"
)

type Token struct {
    Provider     string    `json:"provider"`
    AccessToken  string    `json:"access_token"`
    RefreshToken string    `json:"refresh_token,omitempty"`
    TokenType    string    `json:"token_type,omitempty"`
    Expiry       time.Time `json:"expiry,omitempty"`
    Scope        string    `json:"scope,omitempty"`
}

type Store struct {
    path string
    mu   sync.Mutex
    // keyed by provider name
    tokens map[string]Token
}

func NewStore(path string) *Store <span class="cov4" title="7">{
    return &amp;Store{path: path, tokens: map[string]Token{}}
}</span>

func defaultPath() string <span class="cov1" title="1">{
    home, _ := os.UserHomeDir()
    if home != "" </span><span class="cov1" title="1">{
        return filepath.Join(home, ".config", "lucicodex", "tokens.json")
    }</span>
    <span class="cov0" title="0">return "/etc/lucicodex/tokens.json"</span>
}

func (s *Store) PathOrDefault() string <span class="cov4" title="5">{
    if s.path != "" </span><span class="cov3" title="4">{
        return s.path
    }</span>
    <span class="cov1" title="1">return defaultPath()</span>
}

func (s *Store) Load() error <span class="cov2" title="2">{
    s.mu.Lock()
    defer s.mu.Unlock()
    p := s.PathOrDefault()
    b, err := os.ReadFile(p)
    if err != nil </span><span class="cov1" title="1">{
        if errors.Is(err, os.ErrNotExist) </span><span class="cov1" title="1">{
            s.tokens = map[string]Token{}
            return nil
        }</span>
        <span class="cov0" title="0">return err</span>
    }
    <span class="cov1" title="1">return json.Unmarshal(b, &amp;s.tokens)</span>
}

func (s *Store) Save() error <span class="cov1" title="1">{
    s.mu.Lock()
    defer s.mu.Unlock()
    p := s.PathOrDefault()
    if err := os.MkdirAll(filepath.Dir(p), 0o700); err != nil </span><span class="cov0" title="0">{
        return err
    }</span>
    <span class="cov1" title="1">b, _ := json.MarshalIndent(s.tokens, "", "  ")
    f, err := os.OpenFile(p, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0o600)
    if err != nil </span><span class="cov0" title="0">{
        return err
    }</span>
    <span class="cov1" title="1">defer f.Close()
    _, err = f.Write(b)
    return err</span>
}

func (s *Store) Get(provider string) (Token, bool) <span class="cov10" title="104">{
    s.mu.Lock()
    defer s.mu.Unlock()
    t, ok := s.tokens[provider]
    return t, ok
}</span>

func (s *Store) Put(t Token) <span class="cov9" title="103">{
    s.mu.Lock()
    defer s.mu.Unlock()
    if s.tokens == nil </span><span class="cov0" title="0">{ s.tokens = map[string]Token{} }</span>
    <span class="cov9" title="103">s.tokens[t.Provider] = t</span>
}

func (s *Store) Delete(provider string) <span class="cov1" title="1">{
    s.mu.Lock()
    defer s.mu.Unlock()
    delete(s.tokens, provider)
}</span>


</pre>
		
		<pre class="file" id="file2" style="display: none">package config

import (
        "encoding/json"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strconv"
        "strings"
)

type Config struct {
        Author         string   `json:"author"`
        APIKey         string   `json:"api_key"`  // Gemini API key
        Endpoint       string   `json:"endpoint"` // Active endpoint (set based on provider)
        Model          string   `json:"model"`    // Active model (set based on provider)
        Provider       string   `json:"provider"`
        HTTPProxy      string   `json:"http_proxy"`
        HTTPSProxy     string   `json:"https_proxy"`
        NoProxy        string   `json:"no_proxy"`
        DryRun         bool     `json:"dry_run"`
        AutoApprove    bool     `json:"auto_approve"`
        ConfirmEach    bool     `json:"confirm_each"`
        TimeoutSeconds int      `json:"timeout_seconds"`
        MaxCommands    int      `json:"max_commands"`
        Allowlist      []string `json:"allowlist"`
        Denylist       []string `json:"denylist"`
        LogFile        string   `json:"log_file"`
        ElevateCommand string   `json:"elevate_command"`
        // Retry configuration
        MaxRetries int  `json:"max_retries"`
        AutoRetry  bool `json:"auto_retry"`
        // Provider-specific API keys
        OpenAIAPIKey    string `json:"openai_api_key"`
        AnthropicAPIKey string `json:"anthropic_api_key"`
        // Provider-specific endpoints (stored separately for switching)
        OpenAIEndpoint    string `json:"openai_endpoint"`
        AnthropicEndpoint string `json:"anthropic_endpoint"`
        // Provider-specific models (stored separately for switching)
        OpenAIModel    string `json:"openai_model"`
        AnthropicModel string `json:"anthropic_model"`
}

func defaultConfig() Config <span class="cov3" title="9">{
        return Config{
                Author:            "AZ &lt;Aezi.zhu@icloud.com&gt;",
                Endpoint:          "https://generativelanguage.googleapis.com/v1beta",
                Model:             "gemini-2.5-flash",
                Provider:          "gemini",
                DryRun:            true,
                AutoApprove:       false,
                TimeoutSeconds:    30,
                MaxCommands:       10,
                MaxRetries:        2,
                AutoRetry:         true,
                OpenAIEndpoint:    "https://api.openai.com/v1",
                OpenAIModel:       "gpt-5-mini",
                AnthropicEndpoint: "https://api.anthropic.com/v1",
                AnthropicModel:    "claude-haiku-4-5-20251001",
                Allowlist: []string{
                        `^uci(\s|$)`,
                        `^ubus(\s|$)`,
                        `^fw4(\s|$)`,
                        `^opkg\s+(?:update|install|remove|list(?:-installed|-upgradable)?|info)(?:\s|$)`,
                        `^logread(\s|$)`,
                        `^dmesg(\s|$)`,
                        `^ip(\s|$)`,
                        `^ifstatus(\s|$)`,
                        `^cat(\s|$)`,
                        `^tail(\s|$)`,
                        `^grep(\s|$)`,
                        `^awk(\s|$)`,
                        `^sed(\s|$)`,
                        `^wifi(\s|$)`,
                        `^ping(\s|$)`,
                        `^nslookup(\s|$)`,
                        `^ifconfig(\s|$)`,
                        `^route(\s|$)`,
                        `^iptables(\s|$)`,
                        `^/etc/init\.d/`,
                },
                Denylist: []string{
                        `^rm\s+-rf\s+/`,
                        `^mkfs(\s|$)`,
                        `^dd(\s|$)`,
                        `^:(){:|:&amp;};:`,
                },
                ConfirmEach:    false,
                LogFile:        "/tmp/lucicodex.log",
                ElevateCommand: "",
        }
}</span>

// Load loads configuration from env, UCI (if available), and optional JSON file.
// Precedence: env &gt; UCI &gt; file &gt; defaults
func Load(path string) (Config, error) <span class="cov3" title="8">{
        cfg := defaultConfig()

        // File
        if path == "" </span><span class="cov3" title="5">{
                if fileExists("/etc/lucicodex/config.json") </span><span class="cov0" title="0">{
                        path = "/etc/lucicodex/config.json"
                }</span> else<span class="cov3" title="5"> {
                        home, _ := os.UserHomeDir()
                        p := filepath.Join(home, ".config", "lucicodex", "config.json")
                        if fileExists(p) </span><span class="cov0" title="0">{
                                path = p
                        }</span>
                }
        }
        <span class="cov3" title="8">if path != "" &amp;&amp; fileExists(path) </span><span class="cov2" title="3">{
                b, err := os.ReadFile(path)
                if err != nil </span><span class="cov0" title="0">{
                        return cfg, err
                }</span>
                <span class="cov2" title="3">if err := json.Unmarshal(b, &amp;cfg); err != nil </span><span class="cov1" title="1">{
                        return cfg, err
                }</span>
        }

        // Helper to try main section, then settings section, then api section
        <span class="cov3" title="7">getUci := func(option string) string </span><span class="cov7" title="126">{
                // Try named 'main' section first
                if val, _ := uciGet("lucicodex.main." + option); val != "" </span><span class="cov0" title="0">{
                        return val
                }</span>
                // Try anonymous settings section
                <span class="cov7" title="126">if val, _ := uciGet("lucicodex.@settings[0]." + option); val != "" </span><span class="cov0" title="0">{
                        return val
                }</span>
                // Try anonymous api section (legacy)
                <span class="cov7" title="126">if val, _ := uciGet("lucicodex.@api[0]." + option); val != "" </span><span class="cov0" title="0">{
                        return val
                }</span>
                <span class="cov7" title="126">return ""</span>
        }

        // Load provider first (needed to determine which settings to use)
        <span class="cov3" title="7">if prov := getUci("provider"); prov != "" </span><span class="cov0" title="0">{
                cfg.Provider = prov
        }</span>

        // Load all API keys from UCI
        <span class="cov3" title="7">if key := getUci("key"); key != "" </span><span class="cov0" title="0">{
                cfg.APIKey = key
        }</span>
        <span class="cov3" title="7">if key := getUci("openai_key"); key != "" </span><span class="cov0" title="0">{
                cfg.OpenAIAPIKey = key
        }</span>
        <span class="cov3" title="7">if key := getUci("anthropic_key"); key != "" </span><span class="cov0" title="0">{
                cfg.AnthropicAPIKey = key
        }</span>

        // Load all provider-specific models and endpoints from UCI
        <span class="cov3" title="7">if m := getUci("model"); m != "" </span><span class="cov0" title="0">{
                cfg.Model = m
        }</span>
        <span class="cov3" title="7">if ep := getUci("endpoint"); ep != "" </span><span class="cov0" title="0">{
                cfg.Endpoint = ep
        }</span>
        <span class="cov3" title="7">if m := getUci("openai_model"); m != "" </span><span class="cov0" title="0">{
                cfg.OpenAIModel = m
        }</span>
        <span class="cov3" title="7">if ep := getUci("openai_endpoint"); ep != "" </span><span class="cov0" title="0">{
                cfg.OpenAIEndpoint = ep
        }</span>
        <span class="cov3" title="7">if m := getUci("anthropic_model"); m != "" </span><span class="cov0" title="0">{
                cfg.AnthropicModel = m
        }</span>
        <span class="cov3" title="7">if ep := getUci("anthropic_endpoint"); ep != "" </span><span class="cov0" title="0">{
                cfg.AnthropicEndpoint = ep
        }</span>

        // Load settings from UCI
        <span class="cov3" title="7">if dryRun := getUci("dry_run"); dryRun == "1" </span><span class="cov0" title="0">{
                cfg.DryRun = true
        }</span> else<span class="cov3" title="7"> if dryRun == "0" </span><span class="cov0" title="0">{
                cfg.DryRun = false
        }</span>
        <span class="cov3" title="7">if confirmEach := getUci("confirm_each"); confirmEach == "1" </span><span class="cov0" title="0">{
                cfg.ConfirmEach = true
        }</span> else<span class="cov3" title="7"> if confirmEach == "0" </span><span class="cov0" title="0">{
                cfg.ConfirmEach = false
        }</span>
        <span class="cov3" title="7">if timeout := getUci("timeout"); timeout != "" </span><span class="cov0" title="0">{
                if t, err := strconv.Atoi(timeout); err == nil &amp;&amp; t &gt; 0 </span><span class="cov0" title="0">{
                        cfg.TimeoutSeconds = t
                }</span>
        }
        <span class="cov3" title="7">if maxCmds := getUci("max_commands"); maxCmds != "" </span><span class="cov0" title="0">{
                if m, err := strconv.Atoi(maxCmds); err == nil &amp;&amp; m &gt; 0 </span><span class="cov0" title="0">{
                        cfg.MaxCommands = m
                }</span>
        }
        <span class="cov3" title="7">if logFile := getUci("log_file"); logFile != "" </span><span class="cov0" title="0">{
                cfg.LogFile = logFile
        }</span>
        <span class="cov3" title="7">if proxy := getUci("http_proxy"); proxy != "" </span><span class="cov0" title="0">{
                cfg.HTTPProxy = proxy
        }</span>
        <span class="cov3" title="7">if proxy := getUci("https_proxy"); proxy != "" </span><span class="cov0" title="0">{
                cfg.HTTPSProxy = proxy
        }</span>
        <span class="cov3" title="7">if proxy := getUci("no_proxy"); proxy != "" </span><span class="cov0" title="0">{
                cfg.NoProxy = proxy
        }</span>

        // Environment variables override everything
        <span class="cov3" title="7">if v := strings.TrimSpace(os.Getenv("LUCICODEX_PROVIDER")); v != "" </span><span class="cov2" title="3">{
                cfg.Provider = v
        }</span>
        <span class="cov3" title="7">if v := strings.TrimSpace(os.Getenv("GEMINI_API_KEY")); v != "" </span><span class="cov2" title="3">{
                cfg.APIKey = v
        }</span>
        <span class="cov3" title="7">if v := strings.TrimSpace(os.Getenv("OPENAI_API_KEY")); v != "" </span><span class="cov1" title="2">{
                cfg.OpenAIAPIKey = v
        }</span>
        <span class="cov3" title="7">if v := strings.TrimSpace(os.Getenv("ANTHROPIC_API_KEY")); v != "" </span><span class="cov1" title="1">{
                cfg.AnthropicAPIKey = v
        }</span>
        <span class="cov3" title="7">if v := strings.TrimSpace(os.Getenv("LUCICODEX_MODEL")); v != "" </span><span class="cov2" title="3">{
                cfg.Model = v
        }</span>
        <span class="cov3" title="7">if v := strings.TrimSpace(os.Getenv("GEMINI_ENDPOINT")); v != "" </span><span class="cov0" title="0">{
                cfg.Endpoint = v
        }</span>
        <span class="cov3" title="7">if v := strings.TrimSpace(os.Getenv("LUCICODEX_LOG_FILE")); v != "" </span><span class="cov1" title="1">{
                cfg.LogFile = v
        }</span>
        <span class="cov3" title="7">if v := strings.TrimSpace(os.Getenv("LUCICODEX_ELEVATE")); v != "" </span><span class="cov1" title="1">{
                cfg.ElevateCommand = v
        }</span>
        <span class="cov3" title="7">if v := strings.TrimSpace(os.Getenv("LUCICODEX_CONFIRM_EACH")); v != "" </span><span class="cov0" title="0">{
                cfg.ConfirmEach = v == "1" || strings.ToLower(v) == "true"
        }</span>
        <span class="cov3" title="7">if v := strings.TrimSpace(os.Getenv("LUCICODEX_AUTO_RETRY")); v != "" </span><span class="cov0" title="0">{
                cfg.AutoRetry = v == "1" || strings.ToLower(v) == "true"
        }</span>
        <span class="cov3" title="7">if v := strings.TrimSpace(os.Getenv("LUCICODEX_MAX_RETRIES")); v != "" </span><span class="cov0" title="0">{
                if r, err := strconv.Atoi(v); err == nil &amp;&amp; r &gt;= 0 </span><span class="cov0" title="0">{
                        cfg.MaxRetries = r
                }</span>
        }
        <span class="cov3" title="7">if v := strings.TrimSpace(os.Getenv("HTTP_PROXY")); v != "" </span><span class="cov0" title="0">{
                cfg.HTTPProxy = v
        }</span>
        <span class="cov3" title="7">if v := strings.TrimSpace(os.Getenv("HTTPS_PROXY")); v != "" </span><span class="cov0" title="0">{
                cfg.HTTPSProxy = v
        }</span>
        <span class="cov3" title="7">if v := strings.TrimSpace(os.Getenv("NO_PROXY")); v != "" </span><span class="cov0" title="0">{
                cfg.NoProxy = v
        }</span>

        // Set active Model and Endpoint based on provider
        <span class="cov3" title="7">cfg.ApplyProviderSettings()

        return cfg, nil</span>
}

// ApplyProviderSettings sets the active Model and Endpoint based on the selected provider.
// This should be called after any provider changes (e.g., CLI flag overrides).
func (cfg *Config) ApplyProviderSettings() <span class="cov3" title="7">{
        switch cfg.Provider </span>{
        case "openai":<span class="cov1" title="1">
                if cfg.OpenAIModel != "" </span><span class="cov1" title="1">{
                        cfg.Model = cfg.OpenAIModel
                }</span> else<span class="cov0" title="0"> if cfg.Model == "" || cfg.Model == "gemini-2.5-flash" </span><span class="cov0" title="0">{
                        cfg.Model = "gpt-5-mini"
                }</span>
                <span class="cov1" title="1">if cfg.OpenAIEndpoint != "" </span><span class="cov1" title="1">{
                        cfg.Endpoint = cfg.OpenAIEndpoint
                }</span> else<span class="cov0" title="0"> {
                        cfg.Endpoint = "https://api.openai.com/v1"
                }</span>
        case "anthropic":<span class="cov1" title="1">
                if cfg.AnthropicModel != "" </span><span class="cov1" title="1">{
                        cfg.Model = cfg.AnthropicModel
                }</span> else<span class="cov0" title="0"> if cfg.Model == "" || cfg.Model == "gemini-2.5-flash" </span><span class="cov0" title="0">{
                        cfg.Model = "claude-haiku-4-5-20251001"
                }</span>
                <span class="cov1" title="1">if cfg.AnthropicEndpoint != "" </span><span class="cov1" title="1">{
                        cfg.Endpoint = cfg.AnthropicEndpoint
                }</span> else<span class="cov0" title="0"> {
                        cfg.Endpoint = "https://api.anthropic.com/v1"
                }</span>
        default:<span class="cov3" title="5"> // gemini
                if cfg.Model == "" </span><span class="cov0" title="0">{
                        cfg.Model = "gemini-2.5-flash"
                }</span>
                <span class="cov3" title="5">if cfg.Endpoint == "" </span><span class="cov1" title="2">{
                        cfg.Endpoint = "https://generativelanguage.googleapis.com/v1beta"
                }</span>
        }
}

func fileExists(p string) bool <span class="cov4" title="16">{
        st, err := os.Stat(p)
        return err == nil &amp;&amp; !st.IsDir()
}</span>

func uciGet(key string) (string, error) <span class="cov8" title="378">{
        // Try common UCI paths - web server might not have /sbin in PATH
        uciPaths := []string{"/sbin/uci", "/usr/sbin/uci", "uci"}
        var uciCmd string
        for _, p := range uciPaths </span><span class="cov10" title="1134">{
                if _, err := exec.LookPath(p); err == nil </span><span class="cov0" title="0">{
                        uciCmd = p
                        break</span>
                }
                // Also check if it exists as a file directly
                <span class="cov10" title="1134">if _, err := os.Stat(p); err == nil </span><span class="cov0" title="0">{
                        uciCmd = p
                        break</span>
                }
        }
        <span class="cov8" title="378">if uciCmd == "" </span><span class="cov8" title="378">{
                return "", fmt.Errorf("uci command not found")
        }</span>
        <span class="cov0" title="0">out, err := exec.Command(uciCmd, "-q", "get", key).Output()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return strings.TrimSpace(string(out)), nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package executor

import (
        "context"
        "errors"
        "fmt"
        "os"
        "os/exec"
        "strings"
        "syscall"
        "time"

        "github.com/aezizhu/LuciCodex/internal/config"
        "github.com/aezizhu/LuciCodex/internal/plan"
)

type Result struct {
        Index   int
        Command []string
        Output  string
        Err     error
        Elapsed time.Duration
}

type Results struct {
        Items  []Result
        Failed int
}

// For testing, allow overriding command execution
type execFn func(ctx context.Context, argv []string) (string, error)

var runCommand execFn = defaultRunCommand

func defaultRunCommand(ctx context.Context, argv []string) (string, error) <span class="cov3" title="2">{
        var cmd *exec.Cmd
        if len(argv) == 1 </span><span class="cov0" title="0">{
                cmd = exec.CommandContext(ctx, argv[0])
        }</span> else<span class="cov3" title="2"> {
                cmd = exec.CommandContext(ctx, argv[0], argv[1:]...)
        }</span>
        // Drop env except PATH
        <span class="cov3" title="2">cmd.Env = minimalEnv()
        // Ensure hard kill on deadline
        cmd = commandWithContext(ctx, cmd)

        out, err := cmd.CombinedOutput()
        return string(out), err</span>
}

// GetRunCommand returns the current run command function.
func GetRunCommand() execFn <span class="cov3" title="2">{
        return runCommand
}</span>

// SetRunCommand sets the run command function for testing.
func SetRunCommand(fn execFn) <span class="cov3" title="2">{
        runCommand = fn
}</span>

type Engine struct {
        cfg config.Config
}

func New(cfg config.Config) *Engine <span class="cov9" title="11">{ return &amp;Engine{cfg: cfg} }</span>

func (e *Engine) RunPlan(ctx context.Context, p plan.Plan) Results <span class="cov6" title="4">{
        results := Results{}
        for i, pc := range p.Commands </span><span class="cov7" title="6">{
                r := e.runOne(ctx, i, pc)
                if r.Err != nil </span><span class="cov3" title="2">{
                        results.Failed++
                }</span>
                <span class="cov7" title="6">results.Items = append(results.Items, r)</span>
        }
        <span class="cov6" title="4">return results</span>
}

// RunCommand executes a single planned command and returns the result.
func (e *Engine) RunCommand(ctx context.Context, index int, pc plan.PlannedCommand) Result <span class="cov7" title="6">{
        return e.runOne(ctx, index, pc)
}</span>

func (e *Engine) runOne(ctx context.Context, index int, pc plan.PlannedCommand) Result <span class="cov10" title="12">{
        start := time.Now()
        r := Result{Index: index, Command: pc.Command}
        if len(pc.Command) == 0 </span><span class="cov1" title="1">{
                r.Err = errors.New("empty command")
                return r
        }</span>
        // Set a timeout per command
        <span class="cov9" title="11">timeout := time.Duration(e.cfg.TimeoutSeconds) * time.Second
        if timeout &lt;= 0 </span><span class="cov0" title="0">{
                timeout = 30 * time.Second
        }</span>
        <span class="cov9" title="11">cctx, cancel := context.WithTimeout(ctx, timeout)
        defer cancel()
        // No shell; exec argv directly. Optionally prefix with elevation tool.
        argv := pc.Command
        if pc.NeedsRoot &amp;&amp; strings.TrimSpace(e.cfg.ElevateCommand) != "" </span><span class="cov1" title="1">{
                // Split elevate command into tokens (simple whitespace split; avoid shell features)
                elev := fieldsSafe(e.cfg.ElevateCommand)
                if len(elev) &gt; 0 </span><span class="cov1" title="1">{
                        argv = append(elev, argv...)
                }</span>
        }

        <span class="cov9" title="11">out, err := runCommand(cctx, argv)
        r.Output = out
        r.Err = err
        r.Elapsed = time.Since(start)
        return r</span>
}

func minimalEnv() []string <span class="cov4" title="3">{
        path := os.Getenv("PATH")
        if path == "" </span><span class="cov0" title="0">{
                path = "/usr/sbin:/usr/bin:/sbin:/bin"
        }</span>
        <span class="cov4" title="3">return []string{"PATH=" + path}</span>
}

// commandWithContext ensures the process receives SIGKILL on context deadline.
func commandWithContext(ctx context.Context, cmd *exec.Cmd) *exec.Cmd <span class="cov3" title="2">{
        go func() </span><span class="cov3" title="2">{
                &lt;-
                ctx.Done()
                if ctx.Err() != nil &amp;&amp; cmd.Process != nil </span><span class="cov1" title="1">{
                        // Try SIGTERM then SIGKILL
                        _ = cmd.Process.Signal(syscall.SIGTERM)
                        time.Sleep(500 * time.Millisecond)
                        _ = cmd.Process.Kill()
                }</span>
        }()
        <span class="cov3" title="2">return cmd</span>
}

// FormatCommand returns a shell-like string for logging only (no execution).
func FormatCommand(argv []string) string <span class="cov6" title="5">{
        q := make([]string, 0, len(argv))
        for _, a := range argv </span><span class="cov9" title="11">{
                if strings.ContainsAny(a, "         \n'") </span><span class="cov6" title="4">{
                        q = append(q, fmt.Sprintf("%q", a))
                }</span> else<span class="cov8" title="7"> {
                        q = append(q, a)
                }</span>
        }
        <span class="cov6" title="5">return strings.Join(q, " ")</span>
}

</pre>
		
		<pre class="file" id="file4" style="display: none">package executor

import "unicode"

// fieldsSafe splits on any unicode space without interpreting quotes or escapes.
// This is used for splitting elevate command safely without shell parsing.
func fieldsSafe(s string) []string <span class="cov1" title="1">{
    var out []string
    field := make([]rune, 0, len(s))
    flush := func() </span><span class="cov1" title="1">{
        if len(field) &gt; 0 </span><span class="cov1" title="1">{
            out = append(out, string(field))
            field = field[:0]
        }</span>
    }
    <span class="cov1" title="1">for _, r := range s </span><span class="cov10" title="4">{
        if unicode.IsSpace(r) </span><span class="cov0" title="0">{
            flush()
            continue</span>
        }
        <span class="cov10" title="4">field = append(field, r)</span>
    }
    <span class="cov1" title="1">flush()
    return out</span>
}


</pre>
		
		<pre class="file" id="file5" style="display: none">package llm

import (
        "bytes"
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/http"
        "strings"
        "time"

        "github.com/aezizhu/LuciCodex/internal/config"
        "github.com/aezizhu/LuciCodex/internal/plan"
)

type AnthropicClient struct {
        httpClient *http.Client
        cfg        config.Config
}

func NewAnthropicClient(cfg config.Config) *AnthropicClient <span class="cov8" title="1">{
        return &amp;AnthropicClient{httpClient: newHTTPClient(cfg, 30*time.Second), cfg: cfg}
}</span>

type anthropicMessage struct {
        Role    string `json:"role"`
        Content string `json:"content"`
}

type anthropicReq struct {
        Model     string             `json:"model"`
        Messages  []anthropicMessage `json:"messages"`
        MaxTokens int                `json:"max_tokens"`
}

type anthropicResp struct {
        Content []struct {
                Text string `json:"text"`
        } `json:"content"`
}

func (c *AnthropicClient) GeneratePlan(ctx context.Context, prompt string) (plan.Plan, error) <span class="cov0" title="0">{
        var zero plan.Plan
        if c.cfg.AnthropicAPIKey == "" </span><span class="cov0" title="0">{
                return zero, errors.New("missing Anthropic API key - configure it in LuCI or set ANTHROPIC_API_KEY environment variable")
        }</span>
        <span class="cov0" title="0">model := c.cfg.Model
        if model == "" </span><span class="cov0" title="0">{
                model = "claude-haiku-4-5-20251001"
        }</span>
        // Use configured endpoint or default
        <span class="cov0" title="0">endpoint := c.cfg.Endpoint
        if endpoint == "" </span><span class="cov0" title="0">{
                endpoint = "https://api.anthropic.com/v1"
        }</span>
        // Ensure endpoint ends properly for messages
        <span class="cov0" title="0">url := strings.TrimSuffix(endpoint, "/") + "/messages"

        body := anthropicReq{Model: model, MaxTokens: 2048}
        body.Messages = []anthropicMessage{{Role: "user", Content: prompt}}
        b, _ := json.Marshal(body)
        req, _ := http.NewRequestWithContext(ctx, http.MethodPost, url, bytes.NewReader(b))
        req.Header.Set("Content-Type", "application/json")
        req.Header.Set("x-api-key", c.cfg.AnthropicAPIKey)
        req.Header.Set("anthropic-version", "2023-06-01")
        resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return zero, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()
        if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                data, _ := io.ReadAll(resp.Body)
                return zero, fmt.Errorf("anthropic http %d: %s", resp.StatusCode, string(data))
        }</span>
        <span class="cov0" title="0">var ar anthropicResp
        if err := json.NewDecoder(resp.Body).Decode(&amp;ar); err != nil </span><span class="cov0" title="0">{
                return zero, err
        }</span>
        <span class="cov0" title="0">if len(ar.Content) == 0 </span><span class="cov0" title="0">{
                return zero, errors.New("empty response")
        }</span>
        <span class="cov0" title="0">text := ar.Content[0].Text
        return plan.TryUnmarshalPlan(text)</span>
}

func (c *AnthropicClient) GenerateErrorFix(ctx context.Context, originalCommand string, errorOutput string, attempt int) (plan.Plan, error) <span class="cov0" title="0">{
        prompt := fmt.Sprintf(`You are a router command error fixer for OpenWrt systems.

The following command failed:
Command: %s
Error output: %s
Attempt: %d

Analyze the error and provide a corrected plan to fix the issue. Output strict JSON:
{
  "summary": "brief explanation of the fix",
  "commands": [ { "command": [string, ...], "description": string, "needs_root": bool } ],
  "warnings": [string]
}

Rules:
- Analyze the error carefully (file not found, permission denied, syntax error, etc.)
- Provide alternative commands or fixes
- Use OpenWrt tools: uci, ubus, fw4, opkg, logread, wifi, /etc/init.d/*
- For permission errors, set needs_root to true
- For file not found, check alternative paths or suggest installation
- For syntax errors, correct the command syntax
- Keep the fix minimal and directly actionable
- Common OpenWrt paths: /etc/config/, /var/log/, /sys/class/net/`, originalCommand, errorOutput, attempt)

        return c.GeneratePlan(ctx, prompt)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package llm

import (
        "bytes"
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/http"
        "time"

        "github.com/aezizhu/LuciCodex/internal/config"
        "github.com/aezizhu/LuciCodex/internal/plan"
)

type GeminiClient struct {
        httpClient *http.Client
        cfg        config.Config
}

func NewGeminiClient(cfg config.Config) *GeminiClient <span class="cov4" title="9">{
        return &amp;GeminiClient{
                httpClient: newHTTPClient(cfg, 30*time.Second),
                cfg:        cfg,
        }
}</span>

// API request/response shapes (minimal for our use)
type generateContentRequest struct {
        Contents []content         `json:"contents"`
        Config   *generationConfig `json:"generationConfig,omitempty"`
}

type generationConfig struct {
        ResponseMimeType string `json:"response_mime_type,omitempty"`
}

type content struct {
        Role  string `json:"role,omitempty"`
        Parts []part `json:"parts"`
}

type part struct {
        Text string `json:"text,omitempty"`
}

type generateContentResponse struct {
        Candidates []struct {
                Content content `json:"content"`
        } `json:"candidates"`
        PromptFeedback any `json:"promptFeedback,omitempty"`
}

func (c *GeminiClient) GeneratePlan(ctx context.Context, prompt string) (plan.Plan, error) <span class="cov4" title="8">{
        var zero plan.Plan
        if c.cfg.APIKey == "" </span><span class="cov1" title="1">{
                return zero, errors.New("missing Gemini API key - configure it in LuCI or set GEMINI_API_KEY environment variable")
        }</span>
        <span class="cov4" title="7">model := c.cfg.Model
        if model == "" </span><span class="cov1" title="1">{
                model = "gemini-2.5-flash"
        }</span>
        <span class="cov4" title="7">url := fmt.Sprintf("%s/models/%s:generateContent?key=%s", c.cfg.Endpoint, model, c.cfg.APIKey)

        reqBody := generateContentRequest{
                Contents: []content{{
                        Role:  "user",
                        Parts: []part{{Text: prompt}},
                }},
                Config: &amp;generationConfig{ResponseMimeType: "application/json"},
        }
        b, _ := json.Marshal(reqBody)

        httpReq, err := http.NewRequestWithContext(ctx, http.MethodPost, url, bytes.NewReader(b))
        if err != nil </span><span class="cov0" title="0">{
                return zero, err
        }</span>
        <span class="cov4" title="7">httpReq.Header.Set("Content-Type", "application/json")

        resp, err := c.httpClient.Do(httpReq)
        if err != nil </span><span class="cov1" title="1">{
                return zero, err
        }</span>
        <span class="cov3" title="6">defer resp.Body.Close()
        if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov1" title="1">{
                data, _ := io.ReadAll(resp.Body)
                return zero, fmt.Errorf("gemini http %d: %s", resp.StatusCode, string(data))
        }</span>

        <span class="cov3" title="5">var gcr generateContentResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;gcr); err != nil </span><span class="cov0" title="0">{
                return zero, err
        }</span>
        <span class="cov3" title="5">if len(gcr.Candidates) == 0 || len(gcr.Candidates[0].Content.Parts) == 0 </span><span class="cov1" title="1">{
                return zero, errors.New("empty response")
        }</span>
        <span class="cov3" title="4">text := gcr.Candidates[0].Content.Parts[0].Text
        p, err := plan.TryUnmarshalPlan(text)
        if err != nil </span><span class="cov2" title="2">{
                // try to extract JSON if wrapped in text
                var p2 plan.Plan
                if json.Unmarshal([]byte(extractJSON(text)), &amp;p2) == nil &amp;&amp; len(p2.Commands) &gt; 0 </span><span class="cov1" title="1">{
                        return p2, nil
                }</span>
                <span class="cov1" title="1">return zero, fmt.Errorf("failed to parse plan: %w", err)</span>
        }
        <span class="cov2" title="2">return p, nil</span>
}

func (c *GeminiClient) GenerateErrorFix(ctx context.Context, originalCommand string, errorOutput string, attempt int) (plan.Plan, error) <span class="cov0" title="0">{
        prompt := fmt.Sprintf(`You are a router command error fixer for OpenWrt systems.

The following command failed:
Command: %s
Error output: %s
Attempt: %d

Analyze the error and provide a corrected plan to fix the issue. Output strict JSON:
{
  "summary": "brief explanation of the fix",
  "commands": [ { "command": [string, ...], "description": string, "needs_root": bool } ],
  "warnings": [string]
}

Rules:
- Analyze the error carefully (file not found, permission denied, syntax error, etc.)
- Provide alternative commands or fixes
- Use OpenWrt tools: uci, ubus, fw4, opkg, logread, wifi, /etc/init.d/*
- For permission errors, set needs_root to true
- For file not found, check alternative paths or suggest installation
- For syntax errors, correct the command syntax
- Keep the fix minimal and directly actionable
- Common OpenWrt paths: /etc/config/, /var/log/, /sys/class/net/`, originalCommand, errorOutput, attempt)

        return c.GeneratePlan(ctx, prompt)
}</span>

func extractJSON(s string) string <span class="cov4" title="9">{
        start := -1
        depth := 0
        for i, ch := range s </span><span class="cov10" title="246">{
                if ch == '{' </span><span class="cov4" title="9">{
                        if depth == 0 </span><span class="cov4" title="7">{
                                start = i
                        }</span>
                        <span class="cov4" title="9">depth++</span>
                } else<span class="cov9" title="237"> if ch == '}' </span><span class="cov4" title="9">{
                        depth--
                        if depth == 0 &amp;&amp; start &gt;= 0 </span><span class="cov4" title="7">{
                                return s[start : i+1]
                        }</span>
                }
        }
        <span class="cov2" title="2">return s</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package llm

import (
        "net/http"
        "net/url"
        "strings"
        "time"

        "github.com/aezizhu/LuciCodex/internal/config"
)

func newHTTPClient(cfg config.Config, timeout time.Duration) *http.Client <span class="cov7" title="11">{
        transport := http.DefaultTransport.(*http.Transport).Clone()
        transport.Proxy = proxyFunc(cfg)
        return &amp;http.Client{
                Timeout:   timeout,
                Transport: transport,
        }
}</span>

func proxyFunc(cfg config.Config) func(*http.Request) (*url.URL, error) <span class="cov7" title="11">{
        httpProxyURL := parseProxy(cfg.HTTPProxy)
        httpsProxyURL := parseProxy(cfg.HTTPSProxy)
        noProxyList := parseNoProxy(cfg.NoProxy)

        if httpProxyURL == nil &amp;&amp; httpsProxyURL == nil &amp;&amp; len(noProxyList) == 0 </span><span class="cov7" title="11">{
                return http.ProxyFromEnvironment
        }</span>

        <span class="cov0" title="0">return func(req *http.Request) (*url.URL, error) </span><span class="cov0" title="0">{
                host := strings.ToLower(req.URL.Hostname())
                if host != "" &amp;&amp; shouldBypassProxy(host, noProxyList) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">switch req.URL.Scheme </span>{
                case "https":<span class="cov0" title="0">
                        if httpsProxyURL != nil </span><span class="cov0" title="0">{
                                return httpsProxyURL, nil
                        }</span>
                case "http":<span class="cov0" title="0">
                        if httpProxyURL != nil </span><span class="cov0" title="0">{
                                return httpProxyURL, nil
                        }</span>
                }
                <span class="cov0" title="0">if httpsProxyURL != nil </span><span class="cov0" title="0">{
                        return httpsProxyURL, nil
                }</span>
                <span class="cov0" title="0">if httpProxyURL != nil </span><span class="cov0" title="0">{
                        return httpProxyURL, nil
                }</span>
                <span class="cov0" title="0">return nil, nil</span>
        }
}

func parseProxy(raw string) *url.URL <span class="cov10" title="22">{
        raw = strings.TrimSpace(raw)
        if raw == "" </span><span class="cov10" title="22">{
                return nil
        }</span>
        <span class="cov0" title="0">if !strings.Contains(raw, "://") </span><span class="cov0" title="0">{
                raw = "http://" + raw
        }</span>
        <span class="cov0" title="0">u, err := url.Parse(raw)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return u</span>
}

func parseNoProxy(raw string) []string <span class="cov7" title="11">{
        if strings.TrimSpace(raw) == "" </span><span class="cov7" title="11">{
                return nil
        }</span>
        <span class="cov0" title="0">parts := strings.Split(raw, ",")
        res := make([]string, 0, len(parts))
        for _, part := range parts </span><span class="cov0" title="0">{
                if trimmed := strings.ToLower(strings.TrimSpace(part)); trimmed != "" </span><span class="cov0" title="0">{
                        res = append(res, trimmed)
                }</span>
        }
        <span class="cov0" title="0">return res</span>
}

func shouldBypassProxy(host string, patterns []string) bool <span class="cov0" title="0">{
        for _, pattern := range patterns </span><span class="cov0" title="0">{
                if pattern == "*" </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">if strings.HasPrefix(pattern, ".") </span><span class="cov0" title="0">{
                        if strings.HasSuffix(host, pattern) || host == strings.TrimPrefix(pattern, ".") </span><span class="cov0" title="0">{
                                return true
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov0" title="0">if pattern == host </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">if strings.Contains(pattern, ".") </span><span class="cov0" title="0">{
                        if strings.HasSuffix(host, "."+pattern) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package llm

import (
        "bytes"
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/http"
        "strings"
        "time"

        "github.com/aezizhu/LuciCodex/internal/config"
        "github.com/aezizhu/LuciCodex/internal/plan"
)

type OpenAIClient struct {
        httpClient *http.Client
        cfg        config.Config
}

func NewOpenAIClient(cfg config.Config) *OpenAIClient <span class="cov8" title="1">{
        return &amp;OpenAIClient{httpClient: newHTTPClient(cfg, 30*time.Second), cfg: cfg}
}</span>

type openaiMessage struct {
        Role    string `json:"role"`
        Content string `json:"content"`
}

type openaiReq struct {
        Model          string            `json:"model"`
        Messages       []openaiMessage   `json:"messages"`
        ResponseFormat map[string]string `json:"response_format,omitempty"`
}

type openaiResp struct {
        Choices []struct {
                Message struct {
                        Content string `json:"content"`
                } `json:"message"`
        } `json:"choices"`
}

func (c *OpenAIClient) GeneratePlan(ctx context.Context, prompt string) (plan.Plan, error) <span class="cov0" title="0">{
        var zero plan.Plan
        if c.cfg.OpenAIAPIKey == "" </span><span class="cov0" title="0">{
                return zero, errors.New("missing OpenAI API key - configure it in LuCI or set OPENAI_API_KEY environment variable")
        }</span>
        <span class="cov0" title="0">model := c.cfg.Model
        if model == "" </span><span class="cov0" title="0">{
                model = "gpt-5-mini"
        }</span>
        // Use configured endpoint or default
        <span class="cov0" title="0">endpoint := c.cfg.Endpoint
        if endpoint == "" </span><span class="cov0" title="0">{
                endpoint = "https://api.openai.com/v1"
        }</span>
        // Ensure endpoint ends properly for chat completions
        <span class="cov0" title="0">url := strings.TrimSuffix(endpoint, "/") + "/chat/completions"

        body := openaiReq{Model: model}
        body.Messages = []openaiMessage{{Role: "user", Content: prompt}}
        body.ResponseFormat = map[string]string{"type": "json_object"}
        b, _ := json.Marshal(body)
        req, _ := http.NewRequestWithContext(ctx, http.MethodPost, url, bytes.NewReader(b))
        req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer "+c.cfg.OpenAIAPIKey)
        resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return zero, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()
        if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                data, _ := io.ReadAll(resp.Body)
                return zero, fmt.Errorf("openai http %d: %s", resp.StatusCode, string(data))
        }</span>
        <span class="cov0" title="0">var or openaiResp
        if err := json.NewDecoder(resp.Body).Decode(&amp;or); err != nil </span><span class="cov0" title="0">{
                return zero, err
        }</span>
        <span class="cov0" title="0">if len(or.Choices) == 0 </span><span class="cov0" title="0">{
                return zero, errors.New("empty response")
        }</span>
        <span class="cov0" title="0">text := or.Choices[0].Message.Content
        return plan.TryUnmarshalPlan(text)</span>
}

func (c *OpenAIClient) GenerateErrorFix(ctx context.Context, originalCommand string, errorOutput string, attempt int) (plan.Plan, error) <span class="cov0" title="0">{
        prompt := fmt.Sprintf(`You are a router command error fixer for OpenWrt systems.

The following command failed:
Command: %s
Error output: %s
Attempt: %d

Analyze the error and provide a corrected plan to fix the issue. Output strict JSON:
{
  "summary": "brief explanation of the fix",
  "commands": [ { "command": [string, ...], "description": string, "needs_root": bool } ],
  "warnings": [string]
}

Rules:
- Analyze the error carefully (file not found, permission denied, syntax error, etc.)
- Provide alternative commands or fixes
- Use OpenWrt tools: uci, ubus, fw4, opkg, logread, wifi, /etc/init.d/*
- For permission errors, set needs_root to true
- For file not found, check alternative paths or suggest installation
- For syntax errors, correct the command syntax
- Keep the fix minimal and directly actionable
- Common OpenWrt paths: /etc/config/, /var/log/, /sys/class/net/`, originalCommand, errorOutput, attempt)

        return c.GeneratePlan(ctx, prompt)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package llm

import (
    "context"

    "github.com/aezizhu/LuciCodex/internal/config"
    "github.com/aezizhu/LuciCodex/internal/plan"
)

// Provider is the interface implemented by LLM clients that can produce plans.
type Provider interface {
    GeneratePlan(ctx context.Context, prompt string) (plan.Plan, error)
    GenerateErrorFix(ctx context.Context, originalCommand string, errorOutput string, attempt int) (plan.Plan, error)
}

// NewProvider returns a Provider based on configuration.
func NewProvider(cfg config.Config) Provider <span class="cov0" title="0">{
    switch cfg.Provider </span>{
    case "openai":<span class="cov0" title="0">
        return NewOpenAIClient(cfg)</span>
    case "anthropic":<span class="cov0" title="0">
        return NewAnthropicClient(cfg)</span>
    default:<span class="cov0" title="0">
        return NewGeminiClient(cfg)</span>
    }
}


</pre>
		
		<pre class="file" id="file10" style="display: none">package logging

import (
    "encoding/json"
    "fmt"
    "os"
    "sync"
    "time"

    "github.com/aezizhu/LuciCodex/internal/plan"
)

type Logger struct {
    path string
    mu   sync.Mutex
}

func New(path string) *Logger <span class="cov3" title="3">{ return &amp;Logger{path: path} }</span>

func (l *Logger) writeJSON(event string, data any) <span class="cov10" title="54">{
    if l.path == "" </span><span class="cov2" title="2">{
        return
    }</span>
    <span class="cov9" title="52">l.mu.Lock()
    defer l.mu.Unlock()
    f, err := os.OpenFile(l.path, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0o600)
    if err != nil </span><span class="cov0" title="0">{
        return
    }</span>
    <span class="cov9" title="52">defer f.Close()
    entry := map[string]any{
        "ts":    time.Now().UTC().Format(time.RFC3339Nano),
        "event": event,
        "data":  data,
    }
    b, err := json.Marshal(entry)
    if err != nil </span><span class="cov0" title="0">{
        return
    }</span>
    <span class="cov9" title="52">_, _ = fmt.Fprintln(f, string(b))</span>
}

func (l *Logger) Plan(prompt string, p plan.Plan) <span class="cov9" title="52">{
    l.writeJSON("plan", map[string]any{"prompt": prompt, "plan": p})
}</span>

type ResultItem struct {
    Index   int           `json:"index"`
    Command []string      `json:"command"`
    Output  string        `json:"output"`
    Error   string        `json:"error,omitempty"`
    Elapsed time.Duration `json:"elapsed"`
}

func (l *Logger) Results(items []ResultItem) <span class="cov2" title="2">{
    l.writeJSON("results", items)
}</span>


</pre>
		
		<pre class="file" id="file11" style="display: none">package metrics

import (
    "encoding/json"
    "fmt"
    "os"
    "sync"
    "time"

    "github.com/aezizhu/LuciCodex/internal/plan"
)

// Metrics tracks usage statistics
type Metrics struct {
    mu sync.RWMutex
    
    // Counters
    TotalRequests    int64             `json:"total_requests"`
    TotalCommands    int64             `json:"total_commands"`
    SuccessfulRuns   int64             `json:"successful_runs"`
    FailedRuns       int64             `json:"failed_runs"`
    
    // Timing
    TotalDuration    time.Duration     `json:"total_duration_ns"`
    AverageDuration  time.Duration     `json:"average_duration_ns"`
    
    // Provider usage
    ProviderUsage    map[string]int64  `json:"provider_usage"`
    
    // Command patterns
    CommandPatterns  map[string]int64  `json:"command_patterns"`
    
    // Error tracking
    ErrorTypes       map[string]int64  `json:"error_types"`
    
    // Session info
    StartTime        time.Time         `json:"start_time"`
    LastRequestTime  time.Time         `json:"last_request_time"`
    
    // Recent activity (circular buffer)
    RecentRequests   []RequestMetric   `json:"recent_requests"`
    maxRecent        int
}

// RequestMetric tracks individual request statistics
type RequestMetric struct {
    Timestamp    time.Time     `json:"timestamp"`
    Provider     string        `json:"provider"`
    Prompt       string        `json:"prompt"`
    NumCommands  int           `json:"num_commands"`
    Duration     time.Duration `json:"duration_ns"`
    Success      bool          `json:"success"`
    Error        string        `json:"error,omitempty"`
}

// Collector manages metrics collection
type Collector struct {
    metrics  *Metrics
    filePath string
    saveInterval time.Duration
    stopChan chan struct{}
}

func NewCollector(filePath string) *Collector <span class="cov4" title="5">{
    c := &amp;Collector{
        metrics: &amp;Metrics{
            ProviderUsage:   make(map[string]int64),
            CommandPatterns: make(map[string]int64),
            ErrorTypes:      make(map[string]int64),
            RecentRequests:  make([]RequestMetric, 0, 100),
            maxRecent:       100,
            StartTime:       time.Now(),
        },
        filePath:     filePath,
        saveInterval: 5 * time.Minute,
        stopChan:     make(chan struct{}),
    }
    
    // Load existing metrics
    c.Load()
    
    // Start periodic saving
    go c.periodicSave()
    
    return c
}</span>

func (c *Collector) RecordRequest(provider, prompt string, p plan.Plan, duration time.Duration, err error) <span class="cov9" title="108">{
    c.metrics.mu.Lock()
    defer c.metrics.mu.Unlock()
    
    // Update counters
    c.metrics.TotalRequests++
    c.metrics.TotalCommands += int64(len(p.Commands))
    c.metrics.LastRequestTime = time.Now()
    
    // Update provider usage
    c.metrics.ProviderUsage[provider]++
    
    // Update timing
    c.metrics.TotalDuration += duration
    c.metrics.AverageDuration = time.Duration(int64(c.metrics.TotalDuration) / c.metrics.TotalRequests)
    
    // Track success/failure
    success := err == nil
    if success </span><span class="cov9" title="106">{
        c.metrics.SuccessfulRuns++
    }</span> else<span class="cov2" title="2"> {
        c.metrics.FailedRuns++
        errorType := "unknown"
        if err != nil </span><span class="cov2" title="2">{
            errorType = fmt.Sprintf("%T", err)
        }</span>
        <span class="cov2" title="2">c.metrics.ErrorTypes[errorType]++</span>
    }
    
    // Track command patterns
    <span class="cov9" title="108">for _, cmd := range p.Commands </span><span class="cov10" title="111">{
        if len(cmd.Command) &gt; 0 </span><span class="cov10" title="111">{
            pattern := cmd.Command[0] // First word of command
            c.metrics.CommandPatterns[pattern]++
        }</span>
    }
    
    // Add to recent requests (circular buffer)
    <span class="cov9" title="108">req := RequestMetric{
        Timestamp:   time.Now(),
        Provider:    provider,
        Prompt:      truncateString(prompt, 100),
        NumCommands: len(p.Commands),
        Duration:    duration,
        Success:     success,
    }
    if err != nil </span><span class="cov2" title="2">{
        req.Error = err.Error()
    }</span>
    
    <span class="cov9" title="108">c.addRecentRequest(req)</span>
}

func (c *Collector) addRecentRequest(req RequestMetric) <span class="cov9" title="108">{
    if len(c.metrics.RecentRequests) &gt;= c.metrics.maxRecent </span><span class="cov0" title="0">{
        // Shift left to remove oldest
        copy(c.metrics.RecentRequests, c.metrics.RecentRequests[1:])
        c.metrics.RecentRequests[len(c.metrics.RecentRequests)-1] = req
    }</span> else<span class="cov9" title="108"> {
        c.metrics.RecentRequests = append(c.metrics.RecentRequests, req)
    }</span>
}

func (c *Collector) snapshot() *Metrics <span class="cov5" title="9">{
    c.metrics.mu.RLock()
    defer c.metrics.mu.RUnlock()
    
    out := &amp;Metrics{
        TotalRequests:   c.metrics.TotalRequests,
        TotalCommands:   c.metrics.TotalCommands,
        SuccessfulRuns:  c.metrics.SuccessfulRuns,
        FailedRuns:      c.metrics.FailedRuns,
        TotalDuration:   c.metrics.TotalDuration,
        AverageDuration: c.metrics.AverageDuration,
        StartTime:       c.metrics.StartTime,
        LastRequestTime: c.metrics.LastRequestTime,
        maxRecent:       c.metrics.maxRecent,
    }
    
    out.ProviderUsage = make(map[string]int64, len(c.metrics.ProviderUsage))
    out.CommandPatterns = make(map[string]int64, len(c.metrics.CommandPatterns))
    out.ErrorTypes = make(map[string]int64, len(c.metrics.ErrorTypes))
    
    for k, v := range c.metrics.ProviderUsage </span><span class="cov5" title="12">{
        out.ProviderUsage[k] = v
    }</span>
    <span class="cov5" title="9">for k, v := range c.metrics.CommandPatterns </span><span class="cov5" title="13">{
        out.CommandPatterns[k] = v
    }</span>
    <span class="cov5" title="9">for k, v := range c.metrics.ErrorTypes </span><span class="cov3" title="4">{
        out.ErrorTypes[k] = v
    }</span>
    
    <span class="cov5" title="9">out.RecentRequests = append([]RequestMetric(nil), c.metrics.RecentRequests...)
    
    return out</span>
}

func (c *Collector) GetMetrics() *Metrics <span class="cov3" title="4">{
    return c.snapshot()
}</span>

func (c *Collector) Save() error <span class="cov4" title="5">{
    m := c.snapshot()
    data, err := json.MarshalIndent(m, "", "  ")
    if err != nil </span><span class="cov0" title="0">{
        return err
    }</span>
    
    <span class="cov4" title="5">return os.WriteFile(c.filePath, data, 0o600)</span>
}

func (c *Collector) Load() error <span class="cov4" title="5">{
    data, err := os.ReadFile(c.filePath)
    if err != nil </span><span class="cov3" title="4">{
        if os.IsNotExist(err) </span><span class="cov3" title="4">{
            return nil // No existing metrics file
        }</span>
        <span class="cov0" title="0">return err</span>
    }
    
    <span class="cov1" title="1">c.metrics.mu.Lock()
    defer c.metrics.mu.Unlock()
    
    return json.Unmarshal(data, c.metrics)</span>
}

func (c *Collector) periodicSave() <span class="cov4" title="5">{
    ticker := time.NewTicker(c.saveInterval)
    defer ticker.Stop()
    
    for </span><span class="cov4" title="5">{
        select </span>{
        case &lt;-ticker.C:<span class="cov0" title="0">
            _ = c.Save()</span>
        case &lt;-c.stopChan:<span class="cov4" title="5">
            _ = c.Save() // Final save
            return</span>
        }
    }
}

func (c *Collector) Stop() <span class="cov4" title="5">{
    close(c.stopChan)
}</span>

func (c *Collector) GetSummary() Summary <span class="cov1" title="1">{
    m := c.GetMetrics()
    
    successRate := float64(0)
    if m.TotalRequests &gt; 0 </span><span class="cov1" title="1">{
        successRate = float64(m.SuccessfulRuns) / float64(m.TotalRequests) * 100
    }</span>
    
    <span class="cov1" title="1">return Summary{
        TotalRequests:   m.TotalRequests,
        SuccessRate:     successRate,
        AverageDuration: m.AverageDuration,
        TopProvider:     getTopKey(m.ProviderUsage),
        TopCommand:      getTopKey(m.CommandPatterns),
        Uptime:          time.Since(m.StartTime),
    }</span>
}

// Summary provides a quick overview
type Summary struct {
    TotalRequests   int64         `json:"total_requests"`
    SuccessRate     float64       `json:"success_rate"`
    AverageDuration time.Duration `json:"average_duration"`
    TopProvider     string        `json:"top_provider"`
    TopCommand      string        `json:"top_command"`
    Uptime          time.Duration `json:"uptime"`
}

func getTopKey(m map[string]int64) string <span class="cov2" title="2">{
    var topKey string
    var topCount int64
    
    for k, v := range m </span><span class="cov3" title="4">{
        if v &gt; topCount </span><span class="cov3" title="3">{
            topCount = v
            topKey = k
        }</span>
    }
    
    <span class="cov2" title="2">return topKey</span>
}

func truncateString(s string, maxLen int) string <span class="cov9" title="108">{
    if len(s) &lt;= maxLen </span><span class="cov9" title="108">{
        return s
    }</span>
    <span class="cov0" title="0">return s[:maxLen-3] + "..."</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package openwrt

import (
        "bytes"
        "context"
        "os/exec"
        "strings"
        "time"
)

// runFn defines the signature for a function that can execute a command.
type runFn func(ctx context.Context, name string, args ...string) string

// runCommand is a function variable that points to the default implementation.
// Tests can replace this with a mock implementation.
var runCommand runFn = defaultRun

// CollectFacts gathers lightweight, non-destructive environment information
// to improve planning quality. It tolerates missing tools and timeouts.
func CollectFacts(ctx context.Context) string <span class="cov4" title="3">{
        // Apply an overall cap
        ctx, cancel := context.WithTimeout(ctx, 3*time.Second)
        defer cancel()

        var b bytes.Buffer
        add := func(name string, out string) </span><span class="cov10" title="18">{
                out = strings.TrimSpace(out)
                if out == "" </span><span class="cov8" title="11">{
                        return
                }</span>
                <span class="cov7" title="7">if b.Len() &gt; 0 </span><span class="cov6" title="5">{
                        b.WriteString("\n\n")
                }</span>
                <span class="cov7" title="7">b.WriteString(name)
                b.WriteString(":\n")
                // limit very large outputs
                const max = 4096
                if len(out) &gt; max </span><span class="cov1" title="1">{
                        out = out[:max]
                }</span>
                <span class="cov7" title="7">b.WriteString(out)</span>
        }

        <span class="cov4" title="3">add("/etc/os-release", runCommand(ctx, "cat", "/etc/os-release"))
        add("uname -a", runCommand(ctx, "uname", "-a"))
        add("ubus system board", runCommand(ctx, "ubus", "call", "system", "board", "{}"))
        add("uci show network", runCommand(ctx, "uci", "-q", "show", "network"))
        add("uci show wireless", runCommand(ctx, "uci", "-q", "show", "wireless"))
        add("fw4 print", runCommand(ctx, "fw4", "print"))
        return b.String()</span>
}

func defaultRun(ctx context.Context, name string, args ...string) string <span class="cov0" title="0">{
        // short per-command timeout inside the overall budget
        cctx, cancel := context.WithTimeout(ctx, 1*time.Second)
        defer cancel()
        cmd := exec.CommandContext(cctx, name, args...)
        // minimal env: rely on PATH
        out, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return string(out)</span>
}

// GetRunCommand returns the current run command function.
func GetRunCommand() runFn <span class="cov0" title="0">{
        return runCommand
}</span>

// SetRunCommand sets the run command function for testing.
func SetRunCommand(fn runFn) <span class="cov0" title="0">{
        runCommand = fn
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package plan

import (
    "encoding/json"
    "fmt"
    "strings"
)

// PlannedCommand represents a single command to execute safely without shell interpolation.
type PlannedCommand struct {
    Command     []string `json:"command"`
    Description string   `json:"description,omitempty"`
    NeedsRoot   bool     `json:"needs_root,omitempty"`
}

// Plan is the structured response expected from the model.
type Plan struct {
    Summary  string           `json:"summary,omitempty"`
    Commands []PlannedCommand `json:"commands"`
    Warnings []string         `json:"warnings,omitempty"`
}

// BuildInstruction returns the instruction prefix to reliably elicit a JSON plan.
func BuildInstruction(cfg interface{}) string <span class="cov7" title="4">{
    // Keep instruction concise and deterministic.
    b := &amp;strings.Builder{}
    b.WriteString("You are an OpenWrt router command planner.\n")
    b.WriteString("Output only strict JSON that conforms to this schema:\n")
    b.WriteString("{\n  \"summary\": string,\n  \"commands\": [ { \"command\": [string, ...], \"description\": string, \"needs_root\": bool } ],\n  \"warnings\": [string]\n}\n")
    b.WriteString("Rules:\n")
    b.WriteString("- Use explicit argv arrays; do not return shell pipelines or redirections.\n")
    b.WriteString("- Prefer OpenWrt tools: uci, ubus, fw4, opkg, logread, dmesg, wifi.\n")
    b.WriteString("- Common commands:\n")
    b.WriteString("  Network: uci show network, ip addr, ifconfig, ifstatus &lt;interface&gt;\n")
    b.WriteString("  WiFi: wifi status, uci show wireless, wifi down/up, /etc/init.d/network restart\n")
    b.WriteString("  Firewall: fw4 print, uci show firewall\n")
    b.WriteString("  Packages: opkg update, opkg list-installed, opkg install &lt;pkg&gt;\n")
    b.WriteString("  System: ubus call system board, cat /proc/uptime, free, df -h\n")
    b.WriteString("  Logs: logread | tail -n 20, dmesg | tail -n 20\n")
    b.WriteString("  DNS: nslookup google.com, cat /etc/resolv.conf\n")
    b.WriteString("- Common paths: /etc/config/ (UCI), /var/log/, /sys/class/net/, /tmp/\n")
    b.WriteString("- For 'restart network': use ['/etc/init.d/network', 'restart']\n")
    b.WriteString("- For 'restart wifi': use ['wifi', 'reload'] or ['wifi', 'down'] then ['wifi', 'up']\n")
    b.WriteString("- For system logs: use ['logread'] or ['logread', '-e', 'pattern']\n")
    b.WriteString("- Limit commands to safe, idempotent operations when possible.\n")
    b.WriteString("- Keep the commands minimal and directly actionable.\n")
    return b.String()
}</span>

// BuildInstructionWithLimit adds a hint for maximum number of commands.
func BuildInstructionWithLimit(maxCommands int) string <span class="cov6" title="3">{
    base := BuildInstruction(nil)
    if maxCommands &gt; 0 </span><span class="cov1" title="1">{
        return base + "\nDo not return more than " + fmt.Sprint(maxCommands) + " commands."
    }</span>
    <span class="cov4" title="2">return base</span>
}

// TryUnmarshalPlan attempts to decode a JSON string to Plan.
func TryUnmarshalPlan(s string) (Plan, error) <span class="cov10" title="6">{
    var p Plan
    err := json.Unmarshal([]byte(s), &amp;p)
    return p, err
}</span>


</pre>
		
		<pre class="file" id="file14" style="display: none">package plugins

import (
    "context"
    "encoding/json"
    "fmt"
    "os"
    "os/exec"
    "path/filepath"
    "strings"
    "time"

    "github.com/aezizhu/LuciCodex/internal/plan"
)

// Plugin represents a plugin that can extend LuciCodex functionality
type Plugin interface {
    Name() string
    Description() string
    CanHandle(prompt string) bool
    GeneratePlan(ctx context.Context, prompt string) (plan.Plan, error)
}

// ExternalPlugin implements Plugin for external executable plugins
type ExternalPlugin struct {
    name        string
    description string
    path        string
    keywords    []string
}

// PluginMetadata describes plugin capabilities
type PluginMetadata struct {
    Name        string   `json:"name"`
    Description string   `json:"description"`
    Keywords    []string `json:"keywords"`
    Version     string   `json:"version"`
    Author      string   `json:"author"`
}

// For testing purposes, allow overriding command execution
type execFn func(ctx context.Context, path string, args ...string) ([]byte, error)

var executeCommand execFn = defaultExecute

func defaultExecute(ctx context.Context, path string, args ...string) ([]byte, error) <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, path, args...)
        return cmd.Output()
}</span>

// Manager manages the plugin system
type Manager struct {
        plugins    []Plugin
        pluginDirs []string
}

func NewManager(pluginDirs []string) *Manager <span class="cov1" title="1">{
        return &amp;Manager{
                plugins:    make([]Plugin, 0),
                pluginDirs: pluginDirs,
        }
}</span>

func (m *Manager) LoadPlugins() error <span class="cov1" title="1">{
        for _, dir := range m.pluginDirs </span><span class="cov1" title="1">{
                if err := m.loadFromDir(dir); err != nil </span><span class="cov0" title="0">{
                        // Continue loading other directories even if one fails
                        continue</span>
                }
        }
        <span class="cov1" title="1">return nil</span>
}

func (m *Manager) loadFromDir(dir string) error <span class="cov1" title="1">{
        entries, err := os.ReadDir(dir)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">for _, entry := range entries </span><span class="cov1" title="1">{
                if entry.IsDir() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov1" title="1">pluginPath := filepath.Join(dir, entry.Name())

                // Check if it's executable
                info, err := entry.Info()
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov1" title="1">if info.Mode()&amp;0o111 == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Try to load metadata
                <span class="cov1" title="1">plugin, err := m.loadExternalPlugin(pluginPath)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov1" title="1">m.plugins = append(m.plugins, plugin)</span>
        }

        <span class="cov1" title="1">return nil</span>
}

func (m *Manager) loadExternalPlugin(path string) (*ExternalPlugin, error) <span class="cov1" title="1">{
        // Get plugin metadata
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        output, err := executeCommand(ctx, path, "--metadata")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get metadata: %w", err)
        }</span>

        <span class="cov1" title="1">var metadata PluginMetadata
        if err := json.Unmarshal(output, &amp;metadata); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid metadata: %w", err)
        }</span>

        <span class="cov1" title="1">return &amp;ExternalPlugin{
                name:        metadata.Name,
                description: metadata.Description,
                path:        path,
                keywords:    metadata.Keywords,
        }, nil</span>
}

func (m *Manager) FindPlugin(prompt string) Plugin <span class="cov0" title="0">{
        for _, plugin := range m.plugins </span><span class="cov0" title="0">{
                if plugin.CanHandle(prompt) </span><span class="cov0" title="0">{
                        return plugin
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (m *Manager) ListPlugins() []Plugin <span class="cov1" title="1">{
        return m.plugins
}</span>

// ExternalPlugin implementation
func (p *ExternalPlugin) Name() string <span class="cov1" title="1">{
        return p.name
}</span>

func (p *ExternalPlugin) Description() string <span class="cov0" title="0">{
        return p.description
}</span>

func (p *ExternalPlugin) CanHandle(prompt string) bool <span class="cov1" title="1">{
        promptLower := strings.ToLower(prompt)
        for _, keyword := range p.keywords </span><span class="cov1" title="1">{
                if strings.Contains(promptLower, strings.ToLower(keyword)) </span><span class="cov1" title="1">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (p *ExternalPlugin) GeneratePlan(ctx context.Context, prompt string) (plan.Plan, error) <span class="cov1" title="1">{
        output, err := executeCommand(ctx, p.path, "--plan", prompt)
        if err != nil </span><span class="cov0" title="0">{
                return plan.Plan{}, fmt.Errorf("plugin execution failed: %w", err)
        }</span>

        <span class="cov1" title="1">var planResult plan.Plan
        if err := json.Unmarshal(output, &amp;planResult); err != nil </span><span class="cov0" title="0">{
                return plan.Plan{}, fmt.Errorf("invalid plan output: %w", err)
        }</span>

        <span class="cov1" title="1">return planResult, nil</span>
}

// Built-in plugins

// NetworkPlugin handles network-related requests
type NetworkPlugin struct{}

func (p *NetworkPlugin) Name() string <span class="cov0" title="0">{
    return "network"
}</span>

func (p *NetworkPlugin) Description() string <span class="cov0" title="0">{
    return "Handle network configuration and diagnostics"
}</span>

func (p *NetworkPlugin) CanHandle(prompt string) bool <span class="cov5" title="5">{
    keywords := []string{"network", "wifi", "ethernet", "interface", "ip", "route", "dns"}
    promptLower := strings.ToLower(prompt)
    
    for _, keyword := range keywords </span><span class="cov10" title="28">{
        if strings.Contains(promptLower, keyword) </span><span class="cov3" title="3">{
            return true
        }</span>
    }
    <span class="cov2" title="2">return false</span>
}

func (p *NetworkPlugin) GeneratePlan(ctx context.Context, prompt string) (plan.Plan, error) <span class="cov1" title="1">{
    promptLower := strings.ToLower(prompt)
    
    var commands []plan.PlannedCommand
    
    if strings.Contains(promptLower, "restart") &amp;&amp; strings.Contains(promptLower, "wifi") </span><span class="cov1" title="1">{
        commands = append(commands, plan.PlannedCommand{
            Command:     []string{"uci", "set", "wireless.@wifi-device[0].disabled=1"},
            Description: "Disable WiFi device",
        })
        commands = append(commands, plan.PlannedCommand{
            Command:     []string{"uci", "commit", "wireless"},
            Description: "Commit wireless changes",
        })
        commands = append(commands, plan.PlannedCommand{
            Command:     []string{"wifi", "reload"},
            Description: "Reload WiFi configuration",
        })
        commands = append(commands, plan.PlannedCommand{
            Command:     []string{"uci", "delete", "wireless.@wifi-device[0].disabled"},
            Description: "Re-enable WiFi device",
        })
        commands = append(commands, plan.PlannedCommand{
            Command:     []string{"uci", "commit", "wireless"},
            Description: "Commit wireless changes",
        })
        commands = append(commands, plan.PlannedCommand{
            Command:     []string{"wifi", "reload"},
            Description: "Reload WiFi configuration",
        })
    }</span> else<span class="cov0" title="0"> if strings.Contains(promptLower, "show") &amp;&amp; strings.Contains(promptLower, "interface") </span><span class="cov0" title="0">{
        commands = append(commands, plan.PlannedCommand{
            Command:     []string{"uci", "show", "network"},
            Description: "Show network configuration",
        })
        commands = append(commands, plan.PlannedCommand{
            Command:     []string{"ip", "addr", "show"},
            Description: "Show IP addresses",
        })
    }</span>
    
    <span class="cov1" title="1">return plan.Plan{
        Summary:  "Network operation: " + prompt,
        Commands: commands,
    }, nil</span>
}

// FirewallPlugin handles firewall-related requests
type FirewallPlugin struct{}

func (p *FirewallPlugin) Name() string <span class="cov0" title="0">{
    return "firewall"
}</span>

func (p *FirewallPlugin) Description() string <span class="cov0" title="0">{
    return "Handle firewall configuration and rules"
}</span>

func (p *FirewallPlugin) CanHandle(prompt string) bool <span class="cov5" title="5">{
    keywords := []string{"firewall", "port", "block", "allow", "rule", "fw4"}
    promptLower := strings.ToLower(prompt)
    
    for _, keyword := range keywords </span><span class="cov8" title="18">{
        if strings.Contains(promptLower, keyword) </span><span class="cov3" title="3">{
            return true
        }</span>
    }
    <span class="cov2" title="2">return false</span>
}

func (p *FirewallPlugin) GeneratePlan(ctx context.Context, prompt string) (plan.Plan, error) <span class="cov1" title="1">{
    promptLower := strings.ToLower(prompt)
    
    var commands []plan.PlannedCommand
    
    if strings.Contains(promptLower, "open") &amp;&amp; strings.Contains(promptLower, "port") </span><span class="cov1" title="1">{
        // Extract port number if possible
        port := "22" // default
        if strings.Contains(promptLower, "22") </span><span class="cov0" title="0">{
            port = "22"
        }</span> else<span class="cov1" title="1"> if strings.Contains(promptLower, "80") </span><span class="cov1" title="1">{
            port = "80"
        }</span> else<span class="cov0" title="0"> if strings.Contains(promptLower, "443") </span><span class="cov0" title="0">{
            port = "443"
        }</span>
        
        <span class="cov1" title="1">commands = append(commands, plan.PlannedCommand{
            Command:     []string{"uci", "add", "firewall", "rule"},
            Description: "Add new firewall rule",
        })
        commands = append(commands, plan.PlannedCommand{
            Command:     []string{"uci", "set", "firewall.@rule[-1].name=Allow_Port_" + port},
            Description: "Set rule name",
        })
        commands = append(commands, plan.PlannedCommand{
            Command:     []string{"uci", "set", "firewall.@rule[-1].src=wan"},
            Description: "Set source zone",
        })
        commands = append(commands, plan.PlannedCommand{
            Command:     []string{"uci", "set", "firewall.@rule[-1].proto=tcp"},
            Description: "Set protocol",
        })
        commands = append(commands, plan.PlannedCommand{
            Command:     []string{"uci", "set", "firewall.@rule[-1].dest_port=" + port},
            Description: "Set destination port",
        })
        commands = append(commands, plan.PlannedCommand{
            Command:     []string{"uci", "set", "firewall.@rule[-1].target=ACCEPT"},
            Description: "Set target to accept",
        })
        commands = append(commands, plan.PlannedCommand{
            Command:     []string{"uci", "commit", "firewall"},
            Description: "Commit firewall changes",
        })
        commands = append(commands, plan.PlannedCommand{
            Command:     []string{"fw4", "reload"},
            Description: "Reload firewall",
        })</span>
    }
    
    <span class="cov1" title="1">return plan.Plan{
        Summary:  "Firewall operation: " + prompt,
        Commands: commands,
    }, nil</span>
}

// GetBuiltinPlugins returns all built-in plugins
func GetBuiltinPlugins() []Plugin <span class="cov0" title="0">{
    return []Plugin{
        &amp;NetworkPlugin{},
        &amp;FirewallPlugin{},
    }
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package policy

import (
        "fmt"
        "regexp"
        "strings"

        "github.com/aezizhu/LuciCodex/internal/config"
        "github.com/aezizhu/LuciCodex/internal/plan"
)

type Engine struct {
        cfg      config.Config
        allowREs []*regexp.Regexp
        denyREs  []*regexp.Regexp
}

func New(cfg config.Config) *Engine <span class="cov1" title="1">{
        e := &amp;Engine{cfg: cfg}
        for _, p := range cfg.Allowlist </span><span class="cov4" title="2">{
                if re, err := regexp.Compile(p); err == nil </span><span class="cov4" title="2">{
                        e.allowREs = append(e.allowREs, re)
                }</span>
        }
        <span class="cov1" title="1">for _, p := range cfg.Denylist </span><span class="cov1" title="1">{
                if re, err := regexp.Compile(p); err == nil </span><span class="cov1" title="1">{
                        e.denyREs = append(e.denyREs, re)
                }</span>
        }
        <span class="cov1" title="1">return e</span>
}

func (e *Engine) ValidatePlan(p plan.Plan) error <span class="cov6" title="3">{
        for i, c := range p.Commands </span><span class="cov6" title="3">{
                if len(c.Command) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("command %d is empty", i)
                }</span>
                // Basic argv checks
                <span class="cov6" title="3">for j, a := range c.Command </span><span class="cov10" title="7">{
                        if strings.TrimSpace(a) == "" </span><span class="cov0" title="0">{
                                return fmt.Errorf("command %d arg %d is empty", i, j)
                        }</span>
                        <span class="cov10" title="7">if strings.ContainsAny(a, "\x00") </span><span class="cov0" title="0">{
                                return fmt.Errorf("command %d arg %d contains NUL", i, j)
                        }</span>
                }
                <span class="cov6" title="3">if strings.ContainsAny(c.Command[0], "|&amp;;&gt;&lt;`$") </span><span class="cov0" title="0">{
                        return fmt.Errorf("command %d contains shell metacharacters in argv[0]", i)
                }</span>
                <span class="cov6" title="3">cmdline := strings.Join(c.Command, " ")
                for _, re := range e.denyREs </span><span class="cov6" title="3">{
                        if re.MatchString(cmdline) </span><span class="cov1" title="1">{
                                return fmt.Errorf("command %d denied by policy: %s", i, cmdline)
                        }</span>
                }
                <span class="cov4" title="2">allowed := false
                for _, re := range e.allowREs </span><span class="cov6" title="3">{
                        if re.MatchString(cmdline) </span><span class="cov1" title="1">{
                                allowed = true
                                break</span>
                        }
                }
                <span class="cov4" title="2">if !allowed </span><span class="cov1" title="1">{
                        return fmt.Errorf("command %d not allowed by policy: %s", i, cmdline)
                }</span>
        }
        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package repl

import (
        "bufio"
        "context"
        "fmt"
        "io"
        "strings"
        "time"

        "github.com/aezizhu/LuciCodex/internal/config"
        "github.com/aezizhu/LuciCodex/internal/executor"
        "github.com/aezizhu/LuciCodex/internal/llm"
        "github.com/aezizhu/LuciCodex/internal/logging"
        "github.com/aezizhu/LuciCodex/internal/openwrt"
        "github.com/aezizhu/LuciCodex/internal/plan"
        "github.com/aezizhu/LuciCodex/internal/policy"
        "github.com/aezizhu/LuciCodex/internal/ui"
)

type REPL struct {
        cfg          config.Config
        provider     llm.Provider
        policyEngine *policy.Engine
        execEngine   *executor.Engine
        logger       *logging.Logger
        history      []string
        maxHistory   int
        reader       *bufio.Reader
        writer       io.Writer
}

func New(cfg config.Config, reader io.Reader, writer io.Writer) *REPL <span class="cov4" title="2">{
        return &amp;REPL{
                cfg:          cfg,
                provider:     llm.NewProvider(cfg),
                policyEngine: policy.New(cfg),
                execEngine:   executor.New(cfg),
                logger:       logging.New(cfg.LogFile),
                history:      make([]string, 0),
                maxHistory:   100,
                reader:       bufio.NewReader(reader),
                writer:       writer,
        }
}</span>

func (r *REPL) Run(ctx context.Context) error <span class="cov4" title="2">{
        fmt.Fprintf(r.writer, "LuciCodex interactive mode (provider: %s)\n", r.cfg.Provider)
        fmt.Fprintf(r.writer, "Type 'help' for commands, 'exit' to quit\n\n")

        for </span><span class="cov10" title="7">{
                fmt.Fprint(r.writer, "lucicodex&gt; ")

                line, err := r.reader.ReadString('\n')
                if err != nil </span><span class="cov0" title="0">{
                        if err == io.EOF </span><span class="cov0" title="0">{
                                return nil // Clean exit
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }

                <span class="cov10" title="7">line = strings.TrimSpace(line)
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov10" title="7">if line == "exit" || line == "quit" </span><span class="cov4" title="2">{
                        break</span>
                }

                <span class="cov8" title="5">if err := r.handleCommand(ctx, line, r.writer); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(r.writer, "Error: %v\n", err)
                }</span>

                <span class="cov8" title="5">fmt.Fprintln(r.writer)</span>
        }

        <span class="cov4" title="2">return nil</span>
}
func (r *REPL) handleCommand(ctx context.Context, line string, output io.Writer) error <span class="cov8" title="5">{
        switch </span>{
        case line == "help":<span class="cov1" title="1">
                r.showHelp(output)
                return nil</span>
        case line == "history":<span class="cov1" title="1">
                r.showHistory(output)
                return nil</span>
        case line == "clear":<span class="cov0" title="0">
                r.clearHistory()
                fmt.Fprintln(output, "History cleared")
                return nil</span>
        case line == "status":<span class="cov1" title="1">
                r.showStatus(output)
                return nil</span>
        case strings.HasPrefix(line, "set "):<span class="cov1" title="1">
                return r.handleSet(line[4:], output)</span>
        case strings.HasPrefix(line, "!"):<span class="cov0" title="0">
                return r.handleHistoryCommand(line[1:], ctx, output)</span>
        default:<span class="cov1" title="1">
                return r.executePrompt(ctx, line, output)</span>
        }
}

func (r *REPL) executePrompt(ctx context.Context, prompt string, output io.Writer) error <span class="cov1" title="1">{
        r.addToHistory(prompt)

        // Build instruction with facts
        instruction := plan.BuildInstructionWithLimit(r.cfg.MaxCommands)
        if true </span><span class="cov1" title="1">{ // facts enabled by default in REPL
                factsCtx, cancel := context.WithTimeout(ctx, 3*time.Second)
                defer cancel()
                facts := openwrt.CollectFacts(factsCtx)
                if facts != "" </span><span class="cov1" title="1">{
                        instruction += "\n\nEnvironment facts (read-only):\n" + facts
                }</span>
        }

        <span class="cov1" title="1">fullPrompt := instruction + "\n\nUser request: " + prompt

        // Generate plan
        planCtx, cancel := context.WithTimeout(ctx, 60*time.Second)
        defer cancel()

        p, err := r.provider.GeneratePlan(planCtx, fullPrompt)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("LLM error: %w", err)
        }</span>

        <span class="cov1" title="1">if len(p.Commands) == 0 </span><span class="cov0" title="0">{
                fmt.Fprintln(output, "No commands proposed.")
                return nil
        }</span>

        <span class="cov1" title="1">if r.cfg.MaxCommands &gt; 0 &amp;&amp; len(p.Commands) &gt; r.cfg.MaxCommands </span><span class="cov0" title="0">{
                p.Commands = p.Commands[:r.cfg.MaxCommands]
        }</span>

        // Validate plan
        <span class="cov1" title="1">if err := r.policyEngine.ValidatePlan(p); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Plan rejected: %w", err)
        }</span>

        // Show plan
        <span class="cov1" title="1">ui.PrintPlan(output, p)
        r.logger.Plan(prompt, p)

        if r.cfg.DryRun </span><span class="cov0" title="0">{
                fmt.Fprintln(output, "Dry run mode - no execution")
                return nil
        }</span>

        // Confirm execution
        <span class="cov1" title="1">if !r.cfg.AutoApprove </span><span class="cov1" title="1">{
                ok, err := ui.Confirm(r.reader, output, "Execute these commands?")
                if err != nil || !ok </span><span class="cov0" title="0">{
                        fmt.Fprintln(output, "Cancelled")
                        return nil
                }</span>
        }

        // Execute
        <span class="cov1" title="1">results := r.execEngine.RunPlan(ctx, p)
        ui.PrintResults(output, results)

        // Audit results
        items := make([]logging.ResultItem, 0, len(results.Items))
        for _, it := range results.Items </span><span class="cov1" title="1">{
                errStr := ""
                if it.Err != nil </span><span class="cov0" title="0">{
                        errStr = it.Err.Error()
                }</span>
                <span class="cov1" title="1">items = append(items, logging.ResultItem{
                        Index:   it.Index,
                        Command: it.Command,
                        Output:  it.Output,
                        Error:   errStr,
                        Elapsed: it.Elapsed,
                })</span>
        }
        <span class="cov1" title="1">r.logger.Results(items)

        return nil</span>
}

func (r *REPL) addToHistory(cmd string) <span class="cov4" title="2">{
    r.history = append(r.history, cmd)
    if len(r.history) &gt; r.maxHistory </span><span class="cov0" title="0">{
        r.history = r.history[1:]
    }</span>
}

func (r *REPL) showHelp(output io.Writer) <span class="cov1" title="1">{
    fmt.Fprintln(output, "Available commands:")
    fmt.Fprintln(output, "  help                    - Show this help")
    fmt.Fprintln(output, "  history                 - Show command history")
    fmt.Fprintln(output, "  clear                   - Clear history")
    fmt.Fprintln(output, "  status                  - Show current configuration")
    fmt.Fprintln(output, "  set &lt;key&gt;=&lt;value&gt;       - Change configuration")
    fmt.Fprintln(output, "  !&lt;number&gt;               - Re-run command from history")
    fmt.Fprintln(output, "  exit, quit              - Exit interactive mode")
    fmt.Fprintln(output, "  &lt;natural language&gt;      - Execute AI-planned commands")
}</span>

func (r *REPL) showHistory(output io.Writer) <span class="cov1" title="1">{
    if len(r.history) == 0 </span><span class="cov0" title="0">{
        fmt.Fprintln(output, "No history")
        return
    }</span>
    
    <span class="cov1" title="1">for i, cmd := range r.history </span><span class="cov1" title="1">{
        fmt.Fprintf(output, "%3d  %s\n", i+1, cmd)
    }</span>
}

func (r *REPL) clearHistory() <span class="cov0" title="0">{
    r.history = r.history[:0]
}</span>

func (r *REPL) showStatus(output io.Writer) <span class="cov1" title="1">{
    fmt.Fprintf(output, "Provider: %s\n", r.cfg.Provider)
    fmt.Fprintf(output, "Model: %s\n", r.cfg.Model)
    fmt.Fprintf(output, "Dry run: %t\n", r.cfg.DryRun)
    fmt.Fprintf(output, "Auto approve: %t\n", r.cfg.AutoApprove)
    fmt.Fprintf(output, "Max commands: %d\n", r.cfg.MaxCommands)
    fmt.Fprintf(output, "Timeout: %ds\n", r.cfg.TimeoutSeconds)
}</span>

func (r *REPL) handleSet(setting string, output io.Writer) error <span class="cov1" title="1">{
    parts := strings.SplitN(setting, "=", 2)
    if len(parts) != 2 </span><span class="cov0" title="0">{
        return fmt.Errorf("usage: set key=value")
    }</span>
    
    <span class="cov1" title="1">key, value := strings.TrimSpace(parts[0]), strings.TrimSpace(parts[1])
    
    switch key </span>{
    case "dry-run":<span class="cov1" title="1">
        r.cfg.DryRun = value == "true"
        fmt.Fprintf(output, "Set dry-run to %t\n", r.cfg.DryRun)</span>
    case "auto-approve":<span class="cov0" title="0">
        r.cfg.AutoApprove = value == "true"
        fmt.Fprintf(output, "Set auto-approve to %t\n", r.cfg.AutoApprove)</span>
    case "provider":<span class="cov0" title="0">
        r.cfg.Provider = value
        r.cfg.ApplyProviderSettings() // Apply provider-specific defaults
        r.provider = llm.NewProvider(r.cfg)
        fmt.Fprintf(output, "Set provider to %s (model: %s, endpoint: %s)\n", r.cfg.Provider, r.cfg.Model, r.cfg.Endpoint)</span>
    case "model":<span class="cov0" title="0">
        r.cfg.Model = value
        r.provider = llm.NewProvider(r.cfg)
        fmt.Fprintf(output, "Set model to %s\n", r.cfg.Model)</span>
    default:<span class="cov0" title="0">
        return fmt.Errorf("unknown setting: %s", key)</span>
    }
    
    <span class="cov1" title="1">return nil</span>
}

func (r *REPL) handleHistoryCommand(indexStr string, ctx context.Context, output io.Writer) error <span class="cov0" title="0">{
    if len(r.history) == 0 </span><span class="cov0" title="0">{
        return fmt.Errorf("no history")
    }</span>
    
    <span class="cov0" title="0">var index int
    if indexStr == "" </span><span class="cov0" title="0">{
        index = len(r.history)
    }</span> else<span class="cov0" title="0"> {
        if _, err := fmt.Sscanf(indexStr, "%d", &amp;index); err != nil </span><span class="cov0" title="0">{
            return fmt.Errorf("invalid history index")
        }</span>
    }
    
    <span class="cov0" title="0">if index &lt; 1 || index &gt; len(r.history) </span><span class="cov0" title="0">{
        return fmt.Errorf("history index out of range")
    }</span>
    
    <span class="cov0" title="0">cmd := r.history[index-1]
    fmt.Fprintf(output, "Re-running: %s\n", cmd)
    return r.executePrompt(ctx, cmd, output)</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package security

import (
    "context"
    "fmt"
    "os"
    "os/exec"
    "path/filepath"
    "strings"
    "syscall"
    "time"

    "github.com/aezizhu/LuciCodex/internal/config"
    "github.com/aezizhu/LuciCodex/internal/plan"
)

// ResourceLimits defines execution constraints
type ResourceLimits struct {
    MaxMemoryMB     int           // Maximum memory in MB
    MaxCPUPercent   int           // Maximum CPU percentage
    MaxExecutionTime time.Duration // Maximum execution time
    MaxFileSize     int64         // Maximum file size in bytes
    MaxProcesses    int           // Maximum number of processes
}

// Sandbox provides isolated command execution
type Sandbox struct {
    cfg    config.Config
    limits ResourceLimits
    tmpDir string
}

func NewSandbox(cfg config.Config) *Sandbox <span class="cov3" title="3">{
    return &amp;Sandbox{
        cfg: cfg,
        limits: ResourceLimits{
            MaxMemoryMB:     128,
            MaxCPUPercent:   50,
            MaxExecutionTime: time.Duration(cfg.TimeoutSeconds) * time.Second,
            MaxFileSize:     10 * 1024 * 1024, // 10MB
            MaxProcesses:    10,
        },
        tmpDir: "/tmp/lucicodex-sandbox",
    }
}</span>

func (s *Sandbox) SetLimits(limits ResourceLimits) <span class="cov0" title="0">{
    s.limits = limits
}</span>

func (s *Sandbox) ExecuteCommand(ctx context.Context, pc plan.PlannedCommand) (*exec.Cmd, error) <span class="cov1" title="1">{
    if len(pc.Command) == 0 </span><span class="cov0" title="0">{
        return nil, fmt.Errorf("empty command")
    }</span>

    // Create isolated environment
    <span class="cov1" title="1">if err := s.setupEnvironment(); err != nil </span><span class="cov0" title="0">{
        return nil, fmt.Errorf("setup environment: %w", err)
    }</span>

    // Apply timeout from context or limits
    <span class="cov1" title="1">timeout := s.limits.MaxExecutionTime
    if timeout &lt;= 0 </span><span class="cov0" title="0">{
        timeout = 30 * time.Second
    }</span>
    
    <span class="cov1" title="1">cmdCtx, cancel := context.WithTimeout(ctx, timeout)
    defer cancel()

    // Prepare command with resource limits
    cmd := exec.CommandContext(cmdCtx, pc.Command[0], pc.Command[1:]...)
    
    // Set restricted environment
    cmd.Env = s.getRestrictedEnv()
    
    // Set working directory to sandbox
    cmd.Dir = s.tmpDir
    
    // Apply process limits using SysProcAttr
    cmd.SysProcAttr = &amp;syscall.SysProcAttr{
        // Create new process group for better isolation
        Setpgid: true,
        // Additional security attributes would go here
        // Note: Full sandboxing requires more complex setup
    }

    return cmd, nil</span>
}

func (s *Sandbox) setupEnvironment() error <span class="cov1" title="1">{
    // Create sandbox directory
    if err := os.MkdirAll(s.tmpDir, 0o700); err != nil </span><span class="cov0" title="0">{
        return err
    }</span>

    // Clean up old files
    <span class="cov1" title="1">if err := s.cleanup(); err != nil </span><span class="cov0" title="0">{
        return err
    }</span>

    <span class="cov1" title="1">return nil</span>
}

func (s *Sandbox) cleanup() error <span class="cov2" title="2">{
    // Remove files older than 1 hour
    entries, err := os.ReadDir(s.tmpDir)
    if err != nil </span><span class="cov0" title="0">{
        return err
    }</span>

    <span class="cov2" title="2">cutoff := time.Now().Add(-1 * time.Hour)
    for _, entry := range entries </span><span class="cov2" title="2">{
        info, err := entry.Info()
        if err != nil </span><span class="cov0" title="0">{
            continue</span>
        }
        
        <span class="cov2" title="2">if info.ModTime().Before(cutoff) </span><span class="cov1" title="1">{
            path := filepath.Join(s.tmpDir, entry.Name())
            _ = os.RemoveAll(path)
        }</span>
    }

    <span class="cov2" title="2">return nil</span>
}

func (s *Sandbox) getRestrictedEnv() []string <span class="cov1" title="1">{
    // Minimal environment
    return []string{
        "PATH=/usr/sbin:/usr/bin:/sbin:/bin",
        "HOME=" + s.tmpDir,
        "TMPDIR=" + s.tmpDir,
        "USER=nobody",
        "SHELL=/bin/sh",
    }
}</span>

// ValidateCommand performs additional security checks
func (s *Sandbox) ValidateCommand(pc plan.PlannedCommand) error <span class="cov5" title="8">{
    if len(pc.Command) == 0 </span><span class="cov1" title="1">{
        return fmt.Errorf("empty command")
    }</span>

    // Check for dangerous patterns
    <span class="cov5" title="7">dangerous := []string{
        "/dev/",
        "/proc/",
        "/sys/",
        "../",
        "&amp;&amp;",
        "||",
        "|",
        "&gt;",
        "&lt;",
        "$(",
        "`",
    }

    cmdline := fmt.Sprintf("%v", pc.Command)
    for _, pattern := range dangerous </span><span class="cov10" title="50">{
        if strings.Contains(cmdline, pattern) </span><span class="cov4" title="5">{
            return fmt.Errorf("command contains dangerous pattern: %s", pattern)
        }</span>
    }

    <span class="cov2" title="2">return nil</span>
}

// Monitor tracks resource usage during execution
type Monitor struct {
    cmd       *exec.Cmd
    limits    ResourceLimits
    startTime time.Time
}

func NewMonitor(cmd *exec.Cmd, limits ResourceLimits) *Monitor <span class="cov0" title="0">{
    return &amp;Monitor{
        cmd:       cmd,
        limits:    limits,
        startTime: time.Now(),
    }
}</span>

func (m *Monitor) Start(ctx context.Context) error <span class="cov0" title="0">{
    // Start monitoring in background
    go m.monitorResources(ctx)
    return m.cmd.Start()
}</span>

func (m *Monitor) Wait() error <span class="cov0" title="0">{
    return m.cmd.Wait()
}</span>

func (m *Monitor) monitorResources(ctx context.Context) <span class="cov0" title="0">{
    ticker := time.NewTicker(100 * time.Millisecond)
    defer ticker.Stop()

    for </span><span class="cov0" title="0">{
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
            return</span>
        case &lt;-ticker.C:<span class="cov0" title="0">
            if m.cmd.Process == nil </span><span class="cov0" title="0">{
                return
            }</span>

            // Check execution time
            <span class="cov0" title="0">if time.Since(m.startTime) &gt; m.limits.MaxExecutionTime </span><span class="cov0" title="0">{
                _ = m.cmd.Process.Kill()
                return
            }</span>

            // Additional resource checks would go here
            // (memory usage, CPU usage, etc.)
        }
    }
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package testutil

import (
        "encoding/json"
        "io"
        "net/http"
        "net/http/httptest"
        "os"
        "path/filepath"
        "strings"
        "testing"

        "github.com/aezizhu/LuciCodex/internal/config"
)

// AssertNoError fails the test if err is not nil
func AssertNoError(t *testing.T, err error) <span class="cov0" title="0">{
        t.Helper()
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("expected no error, got: %v", err)
        }</span>
}

// AssertError fails the test if err is nil
func AssertError(t *testing.T, err error) <span class="cov0" title="0">{
        t.Helper()
        if err == nil </span><span class="cov0" title="0">{
                t.Fatal("expected error, got nil")
        }</span>
}

// AssertEqual fails the test if got != want
func AssertEqual(t *testing.T, got, want interface{}) <span class="cov0" title="0">{
        t.Helper()
        if got != want </span><span class="cov0" title="0">{
                t.Fatalf("got %v, want %v", got, want)
        }</span>
}

// AssertContains fails the test if haystack doesn't contain needle
func AssertContains(t *testing.T, haystack, needle string) <span class="cov0" title="0">{
        t.Helper()
        if !strings.Contains(haystack, needle) </span><span class="cov0" title="0">{
                t.Fatalf("expected %q to contain %q", haystack, needle)
        }</span>
}

// AssertNotContains fails the test if haystack contains needle
func AssertNotContains(t *testing.T, haystack, needle string) <span class="cov0" title="0">{
        t.Helper()
        if strings.Contains(haystack, needle) </span><span class="cov0" title="0">{
                t.Fatalf("expected %q to not contain %q", haystack, needle)
        }</span>
}

// AssertTrue fails the test if condition is false
func AssertTrue(t *testing.T, condition bool) <span class="cov0" title="0">{
        t.Helper()
        if !condition </span><span class="cov0" title="0">{
                t.Fatal("expected true, got false")
        }</span>
}

// AssertFalse fails the test if condition is true
func AssertFalse(t *testing.T, condition bool) <span class="cov0" title="0">{
        t.Helper()
        if condition </span><span class="cov0" title="0">{
                t.Fatal("expected false, got true")
        }</span>
}

// TempConfig creates a temporary config file with the given config and returns its path
func TempConfig(t *testing.T, cfg config.Config) string <span class="cov0" title="0">{
        t.Helper()

        tmpDir := t.TempDir()
        configPath := filepath.Join(tmpDir, "config.json")

        data, err := json.Marshal(cfg)
        AssertNoError(t, err)

        err = os.WriteFile(configPath, data, 0644)
        AssertNoError(t, err)

        return configPath
}</span>

// MockHTTPServer creates a mock HTTP server that returns the given response
// The caller is responsible for closing the server
func MockHTTPServer(t *testing.T, statusCode int, responseBody string) *httptest.Server <span class="cov0" title="0">{
        t.Helper()

        return httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.WriteHeader(statusCode)
                _, _ = w.Write([]byte(responseBody))
        }</span>))
}

// MockHTTPServerJSON creates a mock HTTP server that returns JSON response
func MockHTTPServerJSON(t *testing.T, statusCode int, responseData interface{}) *httptest.Server <span class="cov0" title="0">{
        t.Helper()

        return httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(statusCode)
                err := json.NewEncoder(w).Encode(responseData)
                if err != nil </span><span class="cov0" title="0">{
                        t.Logf("failed to encode response: %v", err)
                }</span>
        }))
}

// MockHTTPServerFunc creates a mock HTTP server with a custom handler function
func MockHTTPServerFunc(t *testing.T, handler func(w http.ResponseWriter, r *http.Request)) *httptest.Server <span class="cov0" title="0">{
        t.Helper()
        return httptest.NewServer(http.HandlerFunc(handler))
}</span>

// ReadBody reads the entire request body and returns it as a string
func ReadBody(t *testing.T, r io.Reader) string <span class="cov0" title="0">{
        t.Helper()
        data, err := io.ReadAll(r)
        AssertNoError(t, err)
        return string(data)
}</span>

// DefaultTestConfig returns a default config for testing
func DefaultTestConfig() config.Config <span class="cov0" title="0">{
        return config.Config{
                Author:         "test-author",
                APIKey:         "test-api-key",
                Model:          "test-model",
                Provider:       "gemini",
                Endpoint:       "http://localhost:8080",
                DryRun:         false,
                AutoApprove:    true,
                TimeoutSeconds: 30,
                MaxCommands:    10,
                MaxRetries:     2,
                AutoRetry:      true,
                Allowlist:      []string{"^uci", "^echo"},
                Denylist:       []string{"^rm -rf"},
                LogFile:        "/tmp/test.log",
        }
}</span>

// TempFile creates a temporary file with the given content
func TempFile(t *testing.T, content string) string <span class="cov0" title="0">{
        t.Helper()

        tmpFile, err := os.CreateTemp(t.TempDir(), "test-*")
        AssertNoError(t, err)
        defer tmpFile.Close()

        _, err = tmpFile.WriteString(content)
        AssertNoError(t, err)

        return tmpFile.Name()
}</span>

// TempDir creates a temporary directory
func TempDir(t *testing.T) string <span class="cov0" title="0">{
        t.Helper()
        return t.TempDir()
}</span>

// FileExists checks if a file exists
func FileExists(path string) bool <span class="cov0" title="0">{
        info, err := os.Stat(path)
        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return err == nil &amp;&amp; !info.IsDir()</span>
}

// DirExists checks if a directory exists
func DirExists(path string) bool <span class="cov0" title="0">{
        info, err := os.Stat(path)
        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return err == nil &amp;&amp; info.IsDir()</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package ui

import (
    "encoding/json"
    "io"

    "github.com/aezizhu/LuciCodex/internal/executor"
    "github.com/aezizhu/LuciCodex/internal/plan"
)

func PrintPlanJSON(w io.Writer, p plan.Plan) error <span class="cov8" title="1">{
    enc := json.NewEncoder(w)
    enc.SetIndent("", "  ")
    return enc.Encode(p)
}</span>

func PrintResultsJSON(w io.Writer, res executor.Results) error <span class="cov8" title="1">{
    enc := json.NewEncoder(w)
    enc.SetIndent("", "  ")
    return enc.Encode(res)
}</span>


</pre>
		
		<pre class="file" id="file20" style="display: none">package ui

import (
    "bufio"
    "fmt"
    "io"
    "strings"

    "github.com/aezizhu/LuciCodex/internal/executor"
    "github.com/aezizhu/LuciCodex/internal/plan"
)

func PrintPlan(w io.Writer, p plan.Plan) <span class="cov3" title="2">{
    if p.Summary != "" </span><span class="cov3" title="2">{
        fmt.Fprintf(w, "Summary: %s\n\n", p.Summary)
    }</span>
    <span class="cov3" title="2">for i, c := range p.Commands </span><span class="cov5" title="3">{
        fmt.Fprintf(w, "[%d] %s\n", i+1, executor.FormatCommand(c.Command))
        if strings.TrimSpace(c.Description) != "" </span><span class="cov3" title="2">{
            fmt.Fprintf(w, "    - %s\n", c.Description)
        }</span>
    }
    <span class="cov3" title="2">if len(p.Warnings) &gt; 0 </span><span class="cov1" title="1">{
        fmt.Fprintln(w, "\nWarnings:")
        for _, wmsg := range p.Warnings </span><span class="cov3" title="2">{
            fmt.Fprintf(w, "- %s\n", wmsg)
        }</span>
    }
}

func Confirm(r *bufio.Reader, w io.Writer, msg string) (bool, error) <span class="cov10" title="9">{
    fmt.Fprintf(w, "%s [y/N]: ", msg)
    line, err := r.ReadString('\n')
    if err != nil </span><span class="cov0" title="0">{
        return false, err
    }</span>
    <span class="cov10" title="9">line = strings.TrimSpace(strings.ToLower(line))
    return line == "y" || line == "yes", nil</span>
}

type Results = executor.Results

func PrintResults(w io.Writer, res Results) <span class="cov3" title="2">{
    for _, item := range res.Items </span><span class="cov5" title="3">{
        status := "ok"
        if item.Err != nil </span><span class="cov1" title="1">{
            status = "error"
        }</span>
        <span class="cov5" title="3">fmt.Fprintf(w, "[%d] (%s, %s) %s\n", item.Index+1, status, item.Elapsed, executor.FormatCommand(item.Command))
        if strings.TrimSpace(item.Output) != "" </span><span class="cov3" title="2">{
            fmt.Fprintln(w, indent(item.Output, 2))
        }</span>
    }
    <span class="cov3" title="2">if res.Failed &gt; 0 </span><span class="cov1" title="1">{
        fmt.Fprintf(w, "\n%d command(s) failed.\n", res.Failed)
    }</span> else<span class="cov1" title="1"> {
        fmt.Fprintln(w, "\nAll commands executed successfully.")
    }</span>
}

func indent(s string, n int) string <span class="cov8" title="6">{
    pad := strings.Repeat(" ", n)
    lines := strings.Split(strings.TrimRight(s, "\n"), "\n")
    for i := range lines </span><span class="cov9" title="8">{
        lines[i] = pad + lines[i]
    }</span>
    <span class="cov8" title="6">return strings.Join(lines, "\n")</span>
}


</pre>
		
		<pre class="file" id="file21" style="display: none">package wizard

import (
        "bufio"
        "encoding/json"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strconv"
        "strings"

        "github.com/aezizhu/LuciCodex/internal/config"
)

type Wizard struct {
        reader *bufio.Reader
        writer io.Writer
}

func New(reader io.Reader, writer io.Writer) *Wizard <span class="cov10" title="12">{
        return &amp;Wizard{
                reader: bufio.NewReader(reader),
                writer: writer,
        }
}</span>

func (w *Wizard) Run() error <span class="cov1" title="1">{
        fmt.Fprintf(w.writer, "LuciCodex Setup Wizard\n")
        fmt.Fprintf(w.writer, "===============\n\n")
        fmt.Fprintf(w.writer, "This wizard will help you configure LuciCodex for your OpenWrt router.\n\n")

        cfg := config.Config{
                Author:         "AZ &lt;Aezi.zhu@icloud.com&gt;",
                Endpoint:       "https://generativelanguage.googleapis.com/v1beta",
                Model:          "gemini-2.5-flash",
                Provider:       "gemini",
                DryRun:         true,
                AutoApprove:    false,
                TimeoutSeconds: 30,
                MaxCommands:    10,
                Allowlist: []string{
                        `^uci(\s|$)`,
                        `^ubus(\s|$)`,
                        `^fw4(\s|$)`,
                        `^opkg(\s|$)(update|install|remove|list|info)`,
                        `^logread(\s|$)`,
                        `^dmesg(\s|$)`,
                        `^ip(\s|$)`,
                        `^ifstatus(\s|$)`,
                        `^cat(\s|$)`,
                        `^tail(\s|$)`,
                        `^grep(\s|$)`,
                        `^awk(\s|$)`,
                        `^sed(\s|$)`,
                },
                Denylist: []string{
                        `^rm\s+-rf\s+/`,
                        `^mkfs(\s|$)`,
                        `^dd(\s|$)`,
                        `^:(){:|:&amp;};:`,
                },
                LogFile:        "/tmp/lucicodex.log",
                ElevateCommand: "",
        }

        // Step 1: Choose provider
        if err := w.setupProvider(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Step 2: Configure API credentials
        <span class="cov1" title="1">if err := w.setupCredentials(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Step 3: Security settings
        <span class="cov1" title="1">if err := w.setupSecurity(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Step 4: Save configuration
        <span class="cov1" title="1">return w.saveConfig(cfg)</span>
}

func (w *Wizard) setupProvider(cfg *config.Config) error <span class="cov1" title="1">{
        fmt.Fprintf(w.writer, "Step 1: Choose AI Provider\n")
        fmt.Fprintf(w.writer, "1. Gemini (Google, API key required)\n")
        fmt.Fprintf(w.writer, "2. OpenAI (API key required)\n")
        fmt.Fprintf(w.writer, "3. Anthropic (API key required)\n")

        choice, err := w.readChoice("Enter choice [1-3]", 1, 3)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">switch choice </span>{
        case 1:<span class="cov1" title="1">
                cfg.Provider = "gemini"
                cfg.Model = w.readString("Model (default: gemini-2.5-flash)", "gemini-2.5-flash")</span>
        case 2:<span class="cov0" title="0">
                cfg.Provider = "openai"
                cfg.Model = w.readString("Model (default: gpt-5-mini)", "gpt-5-mini")</span>
        case 3:<span class="cov0" title="0">
                cfg.Provider = "anthropic"
                cfg.Model = w.readString("Model (default: claude-haiku-4-5-20251001)", "claude-haiku-4-5-20251001")</span>
        }

        <span class="cov1" title="1">fmt.Fprintf(w.writer, " Provider configured: %s\n\n", cfg.Provider)
        return nil</span>
}

func (w *Wizard) setupCredentials(cfg *config.Config) error <span class="cov1" title="1">{
        fmt.Fprintf(w.writer, "Step 2: Configure Credentials\n")

        switch cfg.Provider </span>{
        case "gemini":<span class="cov1" title="1">
                fmt.Fprintf(w.writer, "Get your API key from: https://aistudio.google.com/app/apikey\n")
                cfg.APIKey = w.readString("Gemini API key", "")</span>
        case "openai":<span class="cov0" title="0">
                fmt.Fprintf(w.writer, "Get your API key from: https://platform.openai.com/api-keys\n")
                cfg.OpenAIAPIKey = w.readString("OpenAI API key", "")</span>
        case "anthropic":<span class="cov0" title="0">
                fmt.Fprintf(w.writer, "Get your API key from: https://console.anthropic.com/\n")
                cfg.AnthropicAPIKey = w.readString("Anthropic API key", "")</span>
        }

        <span class="cov1" title="1">fmt.Fprintf(w.writer, " Credentials configured\n\n")
        return nil</span>
}

func (w *Wizard) setupSecurity(cfg *config.Config) error <span class="cov1" title="1">{
        fmt.Fprintf(w.writer, "Step 3: Security Settings\n")

        dryRun := w.readBool("Enable dry-run mode by default? (recommended)", true)
        cfg.DryRun = dryRun

        if !dryRun </span><span class="cov1" title="1">{
                autoApprove := w.readBool("Auto-approve commands without confirmation? (not recommended)", false)
                cfg.AutoApprove = autoApprove
        }</span>

        <span class="cov1" title="1">maxCmds := w.readInt("Maximum commands per request", cfg.MaxCommands, 1, 50)
        cfg.MaxCommands = maxCmds

        timeout := w.readInt("Command timeout (seconds)", cfg.TimeoutSeconds, 5, 300)
        cfg.TimeoutSeconds = timeout

        if w.readBool("Configure privilege elevation command (sudo/doas)?", false) </span><span class="cov0" title="0">{
                elevate := w.readString("Elevation command (e.g., 'doas -n' or 'sudo -n')", "")
                cfg.ElevateCommand = elevate
        }</span>

        <span class="cov1" title="1">fmt.Fprintf(w.writer, " Security settings configured\n\n")
        return nil</span>
}

func (w *Wizard) saveConfig(cfg config.Config) error <span class="cov1" title="1">{
        fmt.Fprintf(w.writer, "Step 4: Save Configuration\n")

        paths := []string{
                "/etc/lucicodex/config.json",
                filepath.Join(os.Getenv("HOME"), ".config", "lucicodex", "config.json"),
        }

        fmt.Fprintf(w.writer, "Choose configuration location:\n")
        for i, path := range paths </span><span class="cov3" title="2">{
                fmt.Fprintf(w.writer, "%d. %s\n", i+1, path)
        }</span>

        <span class="cov1" title="1">choice, err := w.readChoice("Enter choice", 1, len(paths))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">configPath := paths[choice-1]

        // Create directory if needed
        if err := os.MkdirAll(filepath.Dir(configPath), 0o755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create config directory: %w", err)
        }</span>

        // Save config
        <span class="cov1" title="1">data, err := json.MarshalIndent(cfg, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("marshal config: %w", err)
        }</span>

        <span class="cov1" title="1">if err := os.WriteFile(configPath, data, 0o600); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("write config: %w", err)
        }</span>

        <span class="cov1" title="1">fmt.Fprintf(w.writer, " Configuration saved to %s\n\n", configPath)
        fmt.Fprintf(w.writer, "Setup complete! You can now run:\n")
        fmt.Fprintf(w.writer, "  lucicodex \"restart wifi\"\n")
        fmt.Fprintf(w.writer, "  lucicodex -interactive\n\n")

        return nil</span>
}

func (w *Wizard) readString(prompt, defaultValue string) string <span class="cov6" title="4">{
        if defaultValue != "" </span><span class="cov4" title="3">{
                fmt.Fprintf(w.writer, "%s [%s]: ", prompt, defaultValue)
        }</span> else<span class="cov1" title="1"> {
                fmt.Fprintf(w.writer, "%s: ", prompt)
        }</span>

        <span class="cov6" title="4">line, _ := w.reader.ReadString('\n')
        line = strings.TrimSpace(line)

        if line == "" </span><span class="cov1" title="1">{
                return defaultValue
        }</span>
        <span class="cov4" title="3">return line</span>
}

func (w *Wizard) readBool(prompt string, defaultValue bool) bool <span class="cov9" title="10">{
        defaultStr := "n"
        if defaultValue </span><span class="cov8" title="8">{
                defaultStr = "y"
        }</span>

        <span class="cov9" title="10">for </span><span class="cov9" title="10">{
                fmt.Fprintf(w.writer, "%s [%s]: ", prompt, defaultStr)
                line, _ := w.reader.ReadString('\n')
                line = strings.TrimSpace(strings.ToLower(line))

                if line == "" </span><span class="cov1" title="1">{
                        return defaultValue
                }</span>

                <span class="cov8" title="9">if line == "y" || line == "yes" </span><span class="cov6" title="4">{
                        return true
                }</span>
                <span class="cov6" title="5">if line == "n" || line == "no" </span><span class="cov6" title="5">{
                        return false
                }</span>

                <span class="cov0" title="0">fmt.Fprintf(w.writer, "Please enter y/yes or n/no\n")</span>
        }
}

func (w *Wizard) readInt(prompt string, defaultValue, min, max int) int <span class="cov6" title="4">{
        for </span><span class="cov6" title="5">{
                fmt.Fprintf(w.writer, "%s [%d]: ", prompt, defaultValue)
                line, _ := w.reader.ReadString('\n')
                line = strings.TrimSpace(line)

                if line == "" </span><span class="cov0" title="0">{
                        return defaultValue
                }</span>

                <span class="cov6" title="5">value, err := strconv.Atoi(line)
                if err != nil </span><span class="cov1" title="1">{
                        fmt.Fprintf(w.writer, "Please enter a valid number\n")
                        continue</span>
                }

                <span class="cov6" title="4">if value &lt; min || value &gt; max </span><span class="cov0" title="0">{
                        fmt.Fprintf(w.writer, "Please enter a number between %d and %d\n", min, max)
                        continue</span>
                }

                <span class="cov6" title="4">return value</span>
        }
}

func (w *Wizard) readChoice(prompt string, min, max int) (int, error) <span class="cov3" title="2">{
        for </span><span class="cov3" title="2">{
                fmt.Fprintf(w.writer, "%s [%d-%d]: ", prompt, min, max)
                line, _ := w.reader.ReadString('\n')
                line = strings.TrimSpace(line)

                choice, err := strconv.Atoi(line)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(w.writer, "Please enter a valid number\n")
                        continue</span>
                }

                <span class="cov3" title="2">if choice &lt; min || choice &gt; max </span><span class="cov0" title="0">{
                        fmt.Fprintf(w.writer, "Please enter a number between %d and %d\n", min, max)
                        continue</span>
                }

                <span class="cov3" title="2">return choice, nil</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
