<%+header%>

    <style>
        /* Apple Minimalist Chat Theme (v2) */
        :root {
            --bg-body: #000000;
            --bg-sidebar: rgba(28, 28, 30, 0.65);
            --bg-chat: #000000;
            --text-primary: #F5F5F7;
            --text-secondary: #86868b;
            --accent-blue: #007AFF;
            --bubble-user-grad: linear-gradient(135deg, #007AFF 0%, #0055B3 100%);
            --bubble-ai: #1c1c1e;
            --border-subtle: rgba(255, 255, 255, 0.1);
            --glass-blur: blur(20px);
            --font-stack: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Helvetica Neue", Helvetica, Arial, sans-serif;
        }

        /* LuCI Navigation Tabs - Improve Visibility */
        .cbi-tabmenu {
            background: rgba(255, 255, 255, 0.05) !important;
            border-bottom: 1px solid var(--border-subtle) !important;
            padding: 0.5rem 1rem !important;
        }

        .cbi-tabmenu li a {
            color: var(--text-secondary) !important;
            background: rgba(255, 255, 255, 0.05) !important;
            border: 1px solid var(--border-subtle) !important;
            padding: 0.6rem 1.5rem !important;
            border-radius: 8px 8px 0 0 !important;
            font-weight: 500 !important;
            transition: all 0.2s ease !important;
        }

        .cbi-tabmenu li a:hover {
            background: rgba(255, 255, 255, 0.1) !important;
            color: var(--text-primary) !important;
            border-color: rgba(255, 255, 255, 0.2) !important;
        }

        .cbi-tabmenu li.cbi-tab a {
            background: var(--accent-blue) !important;
            color: #FFFFFF !important;
            border-color: var(--accent-blue) !important;
        }

        * {

            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: var(--font-stack);
            background: var(--bg-body);
            color: var(--text-primary);
            -webkit-font-smoothing: antialiased;
        }

        .lucicodex-chat {
            display: flex;
            height: calc(100vh - 80px);
            max-width: 1400px;
            margin: 0 auto;
            background: var(--bg-chat);
            border: 1px solid var(--border-subtle);
            border-radius: 24px;
            overflow: hidden;
            box-shadow: 0 40px 80px rgba(0, 0, 0, 0.5);
        }

        /* Sidebar */
        .chat-sidebar {
            width: 280px;
            background: var(--bg-sidebar);
            backdrop-filter: var(--glass-blur);
            -webkit-backdrop-filter: var(--glass-blur);
            border-right: 1px solid var(--border-subtle);
            display: flex;
            flex-direction: column;
            padding: 1.5rem;
        }

        .sidebar-header h2 {
            font-size: 1.1rem;
            font-weight: 600;
            margin: 0 0 0.2rem 0;
            letter-spacing: -0.01em;
        }

        .sidebar-header p {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin: 0 0 1.5rem 0;
        }

        .new-chat-btn {
            width: 100%;
            padding: 0.8rem;
            background: var(--accent-blue);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 0.95rem;
            font-weight: 500;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            margin-bottom: 2rem;
            box-shadow: 0 4px 12px rgba(0, 122, 255, 0.3);
        }

        .new-chat-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(0, 122, 255, 0.4);
        }

        .sidebar-section h3 {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-secondary);
            margin-bottom: 0.8rem;
            font-weight: 600;
            opacity: 0.8;
        }

        .sidebar-select {
            width: 100%;
            padding: 0.6rem;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border-subtle);
            border-radius: 10px;
            color: var(--text-primary);
            font-size: 0.9rem;
            margin-bottom: 2.5rem;
            outline: none;
        }

        .sidebar-section+.sidebar-section {
            padding-top: 1.5rem;
            border-top: 1px solid rgba(255, 255, 255, 0.05);
        }

        .sidebar-section:first-of-type {
            border-top: none;
            padding-top: 0;
        }

        .sidebar-input {
            width: 100%;
            padding: 0.6rem;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border-subtle);
            border-radius: 10px;
            color: var(--text-primary);
            font-size: 0.9rem;
            margin-bottom: 2rem;
            outline: none;
            font-family: var(--font-stack);
        }

        .sidebar-input::placeholder {
            color: var(--text-secondary);
            opacity: 0.6;
        }

        /* Sidebar Grouping */
        .sidebar-group {
            background: rgba(255, 255, 255, 0.02);
            border-radius: 12px;
            padding: 1rem;
            margin-bottom: 1.5rem;
        }

        .chat-history {
            list-style: none;
            padding: 0;
            margin: 0;
            overflow-y: auto;
        }

        .chat-history-item {
            padding: 0.8rem;
            border-radius: 10px;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid transparent;
            position: relative;
            color: var(--text-secondary);
            font-size: 0.9rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .chat-history-item:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.1);
            transform: translateX(2px);
        }

        .chat-history-item.active {
            background: rgba(0, 122, 255, 0.15);
            border-color: rgba(0, 122, 255, 0.3);
            color: var(--text-primary);
            font-weight: 500;
        }

        /* Main Chat */
        .chat-main {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--bg-chat);
            position: relative;
        }

        .message-content {
            flex: 1;
            min-width: 0;
        }

        .message-meta {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.3rem;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0;
            transition: opacity 0.2s;
        }

        .chat-message:hover .message-meta {
            opacity: 1;
        }

        .chat-header {
            padding: 1rem 2rem;
            border-bottom: 1px solid var(--border-subtle);
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
        }

        .chat-header-badge {
            font-size: 0.85rem;
            color: var(--text-secondary);
            font-weight: 500;
            background: rgba(255, 255, 255, 0.05);
            padding: 4px 12px;
            border-radius: 20px;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 2rem;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .chat-message {
            display: flex;
            gap: 0.8rem;
            margin-bottom: 1.5rem;
            animation: messageSlideIn 0.3s ease-out;
        }

        @keyframes messageSlideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .chat-message.user {
            align-self: flex-end;
            flex-direction: row-reverse;
        }

        .message-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: 600;
            flex-shrink: 0;
        }

        .message-avatar.user {
            background: linear-gradient(135deg, #30cfd0 0%, #330867 100%);
            color: white;
        }

        .message-avatar.ai {
            background: #1c1c1e;
            border: 1px solid var(--border-subtle);
            color: var(--text-secondary);
        }

        .message-bubble {
            padding: 0.9rem 1.3rem;
            border-radius: 20px;
            font-size: 1.05rem;
            line-height: 1.5;
            position: relative;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .message-bubble.user {
            background: var(--bubble-user-grad);
            color: white;
            border-bottom-right-radius: 4px;
        }

        .message-bubble.ai {
            background: var(--bubble-ai);
            color: var(--text-primary);
            border: 1px solid var(--border-subtle);
            border-bottom-left-radius: 4px;
        }

        /* Error Messages */
        .message-bubble.error {
            background: rgba(255, 69, 58, 0.15);
            border: 1px solid rgba(255, 69, 58, 0.3);
        }

        .message-bubble.error .message-text {
            color: #FF6B6B;
        }

        .error-icon {
            display: inline-block;
            margin-right: 0.5rem;
        }

        /* Code Blocks */
        .code-block {
            margin: 1rem 0;
            border-radius: 14px;
            overflow: hidden;
            background: #0d0d0e;
            border: 1px solid var(--border-subtle);
        }

        .code-header {
            padding: 0.6rem 1rem;
            background: rgba(255, 255, 255, 0.03);
            font-size: 0.75rem;
            color: var(--text-secondary);
            border-bottom: 1px solid var(--border-subtle);
            display: flex;
            justify-content: space-between;
        }

        .code-content {
            padding: 1.2rem;
            font-family: "SF Mono", "Menlo", monospace;
            font-size: 0.95rem;
            color: #F5F5F7;
            overflow-x: auto;
            line-height: 1.6;
        }

        /* Input Area */
        .chat-input-area {
            padding: 1.5rem 2rem 2rem 2rem;
            background: transparent;
            position: relative;
        }

        .chat-input-wrapper {
            display: flex;
            gap: 0.8rem;
            background: rgba(28, 28, 30, 0.8);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border-subtle);
            border-radius: 30px;
            padding: 0.6rem 0.8rem;
            align-items: flex-end;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            max-width: 900px;
            margin: 0 auto;
        }

        .chat-input {
            flex: 1;
            background: transparent;
            border: none;
            color: white;
            padding: 0.8rem 1rem;
            font-size: 1.05rem;
            font-family: inherit;
            resize: none;
            max-height: 150px;
            line-height: 1.4;
        }

        .chat-input:focus {
            outline: none;
        }

        .btn-send {
            background: var(--accent-blue);
            color: white;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: transform 0.2s;
            font-size: 0.9rem;
            font-weight: 600;
            margin-bottom: 2px;
        }

        .btn-send:hover {
            transform: scale(1.05);
            background: #0062cc;
        }

        /* Typing Indicator */
        .typing-indicator {
            display: flex;
            gap: 5px;
            padding: 4px 8px;
        }

        .typing-dot {
            width: 8px;
            height: 8px;
            background: var(--text-secondary);
            border-radius: 50%;
            animation: bounce 1.4s infinite ease-in-out both;
            opacity: 0.6;
        }

        .typing-dot:nth-child(1) {
            animation-delay: -0.32s;
        }

        .typing-dot:nth-child(2) {
            animation-delay: -0.16s;
        }

        @keyframes bounce {

            0%,
            80%,
            100% {
                transform: scale(0);
            }

            40% {
                transform: scale(1);
            }
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }
    </style>

    <div class="lucicodex-chat">
        <!-- Sidebar -->
        <div class="chat-sidebar">
            <div class="sidebar-header">
                <h2>LuciCodex</h2>
                <p>AI Router Assistant</p>
            </div>

            <button class="new-chat-btn" onclick="startNewChat()">
                <span>+</span> New Chat
            </button>

            <div class="sidebar-section">
                <h3>Execution Mode</h3>
                <select class="sidebar-select" id="execMode" onchange="updateExecMode()">
                    <option value="manual">Manual Review (Safe)</option>
                    <option value="auto">Auto Execute (Risky)</option>
                </select>
            </div>

            <div class="sidebar-section">
                <div class="sidebar-label">PROVIDER</div>
                <select class="sidebar-select" id="providerSelect" onchange="updateProvider()">
                    <option value="">Loading...</option>
                </select>
            </div>

            <div class="sidebar-section">
                <h3>Model (Optional)</h3>
                <input type="text" class="sidebar-input" id="modelInput" placeholder="Leave empty for provider default"
                    oninput="updateModel()" />
            </div>

            <div class="sidebar-section">
                <div
                    style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
                    <h3>History</h3>
                    <button class="btn-delete-history" onclick="clearAllHistory()" title="Clear All"
                        style="opacity: 1; font-size: 0.75rem;">Clear</button>
                </div>
                <ul class="chat-history" id="chatHistory">
                    <!-- History items will be injected here -->
                </ul>
            </div>
        </div>

        <!-- Main Chat Area -->
        <div class="chat-main">
            <div class="chat-header">
                <div class="chat-header-badge">
                    <span>OpenWrt Assistant</span>
                </div>
            </div>

            <div class="chat-messages" id="chatMessages">
                <!-- Messages will be injected here -->
            </div>

            <div class="chat-input-area">
                <div class="chat-input-wrapper">
                    <textarea class="chat-input" id="chatInput" placeholder="Ask LuciCodex to manage your router..."
                        rows="1" onkeydown="handleKeyDown(event)" oninput="autoResize(this)"></textarea>
                    <button class="btn-send" id="sendBtn" onclick="handleSendMessage()">Send</button>
                </div>
            </div>
        </div>
    </div>

    <script type="text/javascript">
        // --- State Management ---
        const state = {
            history: [],
            currentSessionId: null,
            currentMessages: [],
            currentPlan: null,
            execMode: 'manual',
            isProcessing: false,
            provider: '',
            model: ''
        };

        // --- Constants ---
        const API_ENDPOINTS = {
            PLAN: '<%=url("admin/system/lucicodex/plan")%>',
            EXECUTE: '<%=url("admin/system/lucicodex/execute")%>'
        };

        const STORAGE_KEY = 'lucicodex_history_v2';

        // --- Page Init ---
        window.addEventListener('DOMContentLoaded', async () => {
            loadHistory();
            startNewChat(false);

            // Load provider/model from localStorage
            const savedProvider = localStorage.getItem('lucicodex_provider');
            const savedModel = localStorage.getItem('lucicodex_model');

            // Load configured providers from backend
            await loadConfiguredProviders();

            if (savedProvider) {
                state.provider = savedProvider;
                document.getElementById('providerSelect').value = savedProvider;
            }
            if (savedModel) {
                state.model = savedModel;
                document.getElementById('modelInput').value = savedModel;
            }

            // Restore exec mode preference if saved
            const savedMode = localStorage.getItem('lucicodex_exec_mode');
            if (savedMode) {
                state.execMode = savedMode;
                document.getElementById('execMode').value = savedMode;
            }
        });

        // --- Load Configured Providers ---
        async function loadConfiguredProviders() {
            const select = document.getElementById('providerSelect');

            // Fallback: Default providers if endpoint fails
            const allProviders = [
                { value: 'gemini', label: 'Google Gemini' },
                { value: 'openai', label: 'OpenAI' },
                { value: 'anthropic', label: 'Anthropic (Claude)' }
            ];

            try {
                const response = await fetch('/cgi-bin/luci/admin/system/lucicodex/providers');

                if (!response.ok) {
                    console.warn('Providers endpoint returned', response.status, '- using all providers');
                    populateAllProviders(select, allProviders);
                    return;
                }

                const data = await response.json();
                console.log('Loaded providers:', data);

                select.innerHTML = ''; // Clear loading message

                if (data.configured && data.configured.length > 0) {
                    // Use only configured providers
                    const providerNames = {
                        'gemini': 'Google Gemini',
                        'openai': 'OpenAI',
                        'anthropic': 'Anthropic (Claude)'
                    };

                    data.configured.forEach(provider => {
                        const option = document.createElement('option');
                        option.value = provider;
                        option.textContent = providerNames[provider] || provider;
                        select.appendChild(option);
                    });

                    // Set default
                    if (data.default && data.configured.includes(data.default)) {
                        select.value = data.default;
                        state.provider = data.default;
                    } else {
                        select.value = data.configured[0];
                        state.provider = data.configured[0];
                    }
                } else {
                    // No configured providers - show all as fallback
                    console.warn('No providers configured - showing all providers');
                    populateAllProviders(select, allProviders);
                }
            } catch (error) {
                console.error('Failed to load providers:', error);
                // Fallback: Show all providers
                populateAllProviders(select, allProviders);
            }
        }

        function populateAllProviders(select, providers) {
            select.innerHTML = '';
            providers.forEach(p => {
                const option = document.createElement('option');
                option.value = p.value;
                option.textContent = p.label;
                select.appendChild(option);
            });
            // Set default to gemini
            select.value = 'gemini';
            state.provider = 'gemini';
        }

        // --- Core Logic ---

        function startNewChat(confirmAction = true) {
            if (confirmAction && state.currentMessages.length > 1) {
                if (!confirm('Start a new chat? Current conversation is saved.')) return;
            }

            state.currentSessionId = 'session_' + Date.now();
            state.currentMessages = [];
            state.currentPlan = null;

            renderMessages(); // Clears UI
            addMessage('ai', "Hello! I'm LuciCodex. How can I help you manage your OpenWrt router today?");

            updateHistoryUI();
        }

        function handleSendMessage() {
            if (state.isProcessing) return;

            const input = document.getElementById('chatInput');
            const prompt = input.value.trim();

            if (!prompt) return;

            input.value = '';
            autoResize(input);

            addMessage('user', prompt);
            processUserRequest(prompt);
        }

        async function processUserRequest(prompt) {
            setProcessing(true);
            addTypingIndicator();

            try {
                // 1. Generate Plan
                if (state.execMode === 'auto') {
                    if (!confirm('⚠️ AUTO-EXECUTE WARNING\n\nCommands will run IMMEDIATELY without review.\nAre you sure?')) {
                        removeTypingIndicator();
                        setProcessing(false);
                        return;
                    }
                }

                const planResponse = await apiCall(API_ENDPOINTS.PLAN, {
                    prompt,
                    provider: state.provider,
                    model: state.model
                });

                removeTypingIndicator();

                if (!planResponse.ok || !planResponse.plan) {
                    throw new Error(planResponse.error || 'Failed to generate plan');
                }

                state.currentPlan = planResponse.plan;

                // Display Plan Summary
                if (planResponse.plan.summary) {
                    addMessage('ai', planResponse.plan.summary);
                }

                // Display Commands
                if (planResponse.plan.commands && planResponse.plan.commands.length > 0) {
                    for (const cmd of planResponse.plan.commands) {
                        const cmdStr = Array.isArray(cmd.command) ? cmd.command.join(' ') : cmd.command;
                        const desc = cmd.description || 'Execute command';

                        addMessage('ai', desc);
                        addCodeBlock(cmdStr, state.execMode === 'manual');
                    }
                } else {
                    addMessage('ai', 'No commands needed for this request.');
                }

                // Auto Execute if mode is auto
                if (state.execMode === 'auto' && planResponse.plan.commands.length > 0) {
                    await executeCommands(prompt);
                }

            } catch (error) {
                removeTypingIndicator();

                // Detect specific error code
                const errorInfo = detectErrorCode(error, error.response);

                // Build detailed error message
                let errorMsg = `**${errorInfo.title}** (${errorInfo.code})`;
                errorMsg += `\n\n${errorInfo.message}`;

                // Add solution
                errorMsg += `\n\n**Solution:**\n${errorInfo.solution}`;

                // Add technical details if available
                if (error.response && error.response.details) {
                    const details = error.response.details;
                    errorMsg += '\n\n**Technical Details:**';

                    if (details.backend_error) {
                        errorMsg += `\n- Backend: ${details.backend_error.trim()}`;
                    }
                    if (details.exit_code) {
                        errorMsg += `\n- Exit Code: ${details.exit_code}`;
                    }
                }

                addMessage('ai', errorMsg);
            } finally {
                setProcessing(false);
                saveCurrentSession();
            }
        }

        async function executeCommands(prompt) {
            addTypingIndicator();
            setProcessing(true);

            try {
                const execResponse = await apiCall(API_ENDPOINTS.EXECUTE, {
                    prompt,
                    dry_run: false,
                    timeout: 30,
                    provider: state.provider,
                    model: state.model
                });

                removeTypingIndicator();

                if (execResponse.ok) {
                    const output = execResponse.output || JSON.stringify(execResponse.result, null, 2);
                    addResultBlock(output, true);
                } else {
                    addResultBlock(execResponse.error || 'Execution failed', false);
                    if (execResponse.output) {
                        addResultBlock(execResponse.output, false);
                    }
                }
            } catch (error) {
                removeTypingIndicator();
                addResultBlock(error.message, false);
            } finally {
                setProcessing(false);
                saveCurrentSession();
            }
        }

        function approveCommand(code) {
            // In this simplified flow, approving one command executes the whole plan for now
            // Ideally we should track which command is which, but for CLI wrapper, 
            // we usually re-send the prompt with -approve flag.
            // We'll use the last user prompt.
            const lastUserMsg = state.currentMessages.slice().reverse().find(m => m.role === 'user');
            if (lastUserMsg) {
                // Remove the approval buttons to prevent double-click
                const buttons = document.querySelectorAll('.btn-approve, .btn-reject');
                buttons.forEach(b => b.remove());

                executeCommands(lastUserMsg.content);
            }
        }

        function rejectCommand() {
            const buttons = document.querySelectorAll('.btn-approve, .btn-reject');
            buttons.forEach(b => b.remove());
            addMessage('ai', 'Command execution cancelled.');
        }

        // --- Error Code Detection ---
        function detectErrorCode(error, response) {
            const errorText = (error.message + ' ' + (response?.details?.backend_error || '')).toLowerCase();

            // Missing API Keys
            if (errorText.includes('missing openai_api_key')) {
                return {
                    code: 'ERR_MISSING_OPENAI_KEY',
                    title: 'Missing OpenAI API Key',
                    message: 'Please configure your OpenAI API key in Settings.',
                    solution: 'Go to Configuration → OpenAI API Key and enter your key from https://platform.openai.com/api-keys'
                };
            }
            if (errorText.includes('missing anthropic_api_key')) {
                return {
                    code: 'ERR_MISSING_ANTHROPIC_KEY',
                    title: 'Missing Anthropic API Key',
                    message: 'Please configure your Anthropic API key in Settings.',
                    solution: 'Go to Configuration → Anthropic API Key and enter your key from https://console.anthropic.com/'
                };
            }
            if (errorText.includes('missing api key') || errorText.includes('missing gemini')) {
                return {
                    code: 'ERR_MISSING_GEMINI_KEY',
                    title: 'Missing Gemini API Key',
                    message: 'Please configure your Gemini API key in Settings.',
                    solution: 'Go to Configuration → Gemini API Key and enter your key from https://makersuite.google.com/app/apikey'
                };
            }

            // Authentication Errors
            if (errorText.includes('401') || errorText.includes('unauthorized') || errorText.includes('invalid api key')) {
                return {
                    code: 'ERR_AUTH_FAILED',
                    title: 'Authentication Failed',
                    message: 'Your API key is invalid or has been revoked.',
                    solution: 'Check your API key in Configuration and ensure it is correct and active.'
                };
            }

            // Rate Limiting
            if (errorText.includes('429') || errorText.includes('rate limit') || errorText.includes('quota exceeded')) {
                return {
                    code: 'ERR_RATE_LIMIT',
                    title: 'Rate Limit Exceeded',
                    message: 'You have exceeded the API rate limit or quota.',
                    solution: 'Wait a few minutes and try again, or upgrade your API plan.'
                };
            }

            // Timeout Errors
            if (errorText.includes('timeout') || errorText.includes('timed out')) {
                return {
                    code: 'ERR_TIMEOUT',
                    title: 'Request Timeout',
                    message: 'The request took too long to complete.',
                    solution: 'Check your internet connection and try again with a simpler request.'
                };
            }

            // Model Errors
            if (errorText.includes('model') && (errorText.includes('not found') || errorText.includes('does not exist'))) {
                return {
                    code: 'ERR_MODEL_NOT_FOUND',
                    title: 'Model Not Found',
                    message: 'The specified model does not exist or is not accessible.',
                    solution: 'Check the model name in your provider settings or chat sidebar.'
                };
            }

            // Network Errors
            if (errorText.includes('network') || errorText.includes('econnrefused') || errorText.includes('dns')) {
                return {
                    code: 'ERR_NETWORK',
                    title: 'Network Error',
                    message: 'Unable to connect to the LLM service.',
                    solution: 'Check your router\'s internet connection and DNS settings.'
                };
            }

            // Generic error
            return {
                code: 'ERR_UNKNOWN',
                title: 'Unknown Error',
                message: error.message,
                solution: 'Check the error details below for more information.'
            };
        }

        // --- API Helper ---
        function apiCall(url, data) {
            return new Promise((resolve, reject) => {
                const xhr = new XMLHttpRequest();
                xhr.open('POST', url, true);
                xhr.setRequestHeader('Content-Type', 'application/json');
                xhr.timeout = 60000; // 60s timeout

                xhr.onload = () => {
                    if (xhr.status === 200) {
                        try {
                            resolve(JSON.parse(xhr.responseText));
                        } catch (e) {
                            reject(new Error('Invalid JSON response'));
                        }
                    } else {
                        try {
                            const err = JSON.parse(xhr.responseText);
                            const error = new Error(err.error || `Request failed (${xhr.status})`);
                            error.response = err; // Attach full response for detailed error display
                            reject(error);
                        } catch (e) {
                            reject(new Error(`Request failed (${xhr.status})`));
                        }
                    }
                };

                xhr.onerror = () => reject(new Error('Network error'));
                xhr.ontimeout = () => reject(new Error('Request timed out'));

                xhr.send(JSON.stringify(data));
            });
        }

        // --- UI Helpers ---

        function addMessage(role, content) {
            state.currentMessages.push({ role, type: 'text', content, timestamp: Date.now() });

            const div = document.createElement('div');
            div.className = `chat-message ${role}`;

            // Detect error messages
            const isError = content.toLowerCase().includes('error:') || content.startsWith('**Error:**');
            const bubbleClass = isError ? 'error' : role;

            let avatarHtml = role === 'user' ? 'U' : 'AI';
            if (role === 'ai') {
                avatarHtml = getProviderIcon(state.provider);
            }

            const formattedContent = parseMarkdown(content);
            const timestamp = new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });

            div.innerHTML = `
        <div class="message-avatar ${role}">${avatarHtml}</div>
        <div class="message-content">
            <div class="message-meta">
                <span>${role === 'user' ? 'You' : 'AI'}</span>
                <span>•</span>
                <span>${timestamp}</span>
            </div>
            <div class="message-bubble ${bubbleClass}">
                <div class="message-text">${isError ? '<span class="error-icon">⚠️</span>' : ''}${formattedContent}</div>
            </div>
        </div>
    `;

            document.getElementById('chatMessages').appendChild(div);
            scrollToBottom();
        }

        function addCodeBlock(code, needsApproval) {
            state.currentMessages.push({ role: 'ai', type: 'code', content: code, needsApproval, timestamp: Date.now() });

            const div = document.createElement('div');
            div.className = 'chat-message ai';

            let approvalHtml = '';
            if (needsApproval) {
                approvalHtml = `
            <div class="command-approval">
                <div class="command-approval-header">⚠️ Approval Required</div>
                <div class="command-approval-actions">
                    <button class="btn-approve" onclick="approveCommand()">✓ Approve & Execute</button>
                    <button class="btn-reject" onclick="rejectCommand()">✗ Reject</button>
                </div>
            </div>
        `;
            }

            div.innerHTML = `
        <div class="message-avatar ai">${getProviderIcon(state.provider)}</div>
        <div class="message-content">
            <div class="message-bubble ai">
                <div class="code-block">
                    <div class="code-header">SHELL</div>
                    <div class="code-content"><pre>${escapeHtml(code)}</pre></div>
                </div>
                ${approvalHtml}
            </div>
        </div>
    `;

            document.getElementById('chatMessages').appendChild(div);
            scrollToBottom();
        }

        function addResultBlock(output, isSuccess) {
            state.currentMessages.push({ role: 'ai', type: 'result', content: output, isSuccess, timestamp: Date.now() });

            const div = document.createElement('div');
            div.className = 'chat-message ai';
            const resultClass = isSuccess ? 'result-success' : 'result-error';
            const title = isSuccess ? '✓ Execution Result' : '✗ Execution Error';

            div.innerHTML = `
        <div class="message-avatar ai">${getProviderIcon(state.provider)}</div>
        <div class="message-content">
            <div class="message-bubble ai">
                <div class="result-block ${resultClass}">
                    <div class="result-header">${title}</div>
                    <div class="result-content">${escapeHtml(output)}</div>
                </div>
            </div>
        </div>
    `;

            document.getElementById('chatMessages').appendChild(div);
            scrollToBottom();
        }

        function addTypingIndicator() {
            const div = document.createElement('div');
            div.className = 'chat-message ai';
            div.id = 'typingIndicator';
            div.innerHTML = `
        <div class="message-avatar ai">${getProviderIcon(state.provider)}</div>
        <div class="message-content">
            <div class="message-bubble ai">
                <div class="typing-indicator">
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                </div>
            </div>
        </div>
    `;
            document.getElementById('chatMessages').appendChild(div);
            scrollToBottom();
        }

        function removeTypingIndicator() {
            const el = document.getElementById('typingIndicator');
            if (el) el.remove();
        }

        function renderMessages() {
            const container = document.getElementById('chatMessages');
            container.innerHTML = '';

            // Re-render from state
            // Note: In a full app we might want to optimize this, but for now clearing and re-adding is fine
            // However, since we push to DOM immediately in addMessage, we only need this when loading history
        }

        function scrollToBottom() {
            const container = document.getElementById('chatMessages');
            container.scrollTop = container.scrollHeight;
        }

        function setProcessing(processing) {
            state.isProcessing = processing;
            document.getElementById('chatInput').disabled = processing;
            document.getElementById('sendBtn').disabled = processing;
            if (!processing) {
                document.getElementById('chatInput').focus();
            }
        }

        function autoResize(textarea) {
            textarea.style.height = 'auto';
            textarea.style.height = Math.min(textarea.scrollHeight, 150) + 'px';
        }

        function handleKeyDown(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                handleSendMessage();
            }
        }

        function updateExecMode() {
            state.execMode = document.getElementById('execMode').value;
            localStorage.setItem('lucicodex_exec_mode', state.execMode);
        }

        // --- Icons ---
        const ICONS = {
            gemini: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/></svg>`, // Placeholder for Gemini
            openai: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm0 18a8 8 0 1 1 8-8 8 8 0 0 1-8 8z"/></svg>`, // Placeholder for OpenAI
            anthropic: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2L2 22h20L12 2zm0 4l6.5 13h-13L12 6z"/></svg>`, // Placeholder for Anthropic
            default: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2a10 10 0 0 1 10 10c0 5.523-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2zm0 2a8 8 0 1 0 0 16 8 8 0 0 0 0-16zm-1 5h2v6h-2V9zm0 8h2v2h-2v-2z"/></svg>`
        };

        function getProviderIcon(provider) {
            // Real logos (SVG paths)
            if (provider === 'gemini') {
                return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="24" height="24"><path d="M11.55 21.65c.25.25.65.25.9 0l8.5-8.5c.25-.25.25-.65 0-.9l-8.5-8.5c-.25-.25-.65-.25-.9 0L3.05 12.25c-.25.25-.25.65 0 .9l8.5 8.5zm.45-1.5l-7.6-7.6 7.6-7.6 7.6 7.6-7.6 7.6z"/></svg>`; // Star/Sparkle
            }
            if (provider === 'openai') {
                return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="24" height="24"><path d="M21.71 10.38a9.1 9.1 0 0 0-3.2-5.54 9.1 9.1 0 0 0-5.55-3.2A9.1 9.1 0 0 0 2.29 13.62a9.1 9.1 0 0 0 3.2 5.54 9.1 9.1 0 0 0 5.55 3.2 9.1 9.1 0 0 0 10.67-11.98zm-1.84 6.78a7.1 7.1 0 0 1-4.22 2.44 7.1 7.1 0 0 1-5.18-.78l.84-1.46a5.4 5.4 0 0 0 3.94.6 5.4 5.4 0 0 0 3.2-1.86l1.42.84zM5.5 17.16a7.1 7.1 0 0 1-1.38-4.86 7.1 7.1 0 0 1 2.44-4.22l1.08 1.3a5.4 5.4 0 0 0-1.86 3.2 5.4 5.4 0 0 0 1.06 3.7l-1.34.88zm1.3-11.66a7.1 7.1 0 0 1 4.86-1.38 7.1 7.1 0 0 1 4.22 2.44l-1.3 1.08a5.4 5.4 0 0 0-3.2-1.86 5.4 5.4 0 0 0-3.7 1.06l-.88-1.34zm11.7 4.86a5.4 5.4 0 0 0-1.06-3.7l1.34-.88a7.1 7.1 0 0 1 1.38 4.86 7.1 7.1 0 0 1-2.44 4.22l-1.08-1.3a5.4 5.4 0 0 0 1.86-3.2zM12 13.5a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3z"/></svg>`; // Swirl
            }
            if (provider === 'anthropic') {
                return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="24" height="24"><path d="M17.5 19c0 .83-.67 1.5-1.5 1.5H8c-.83 0-1.5-.67-1.5-1.5V5c0-.83.67-1.5 1.5-1.5h8c.83 0 1.5.67 1.5 1.5v14zm-9.5 0h8V5H8v14z"/></svg>`; // Simple rectangle/monolith
            }
            return `<span style="font-weight:bold;font-size:0.8rem;">AI</span>`;
        }

        function updateProvider() {
            state.provider = document.getElementById('providerSelect').value;
            localStorage.setItem('lucicodex_provider', state.provider);
        }

        function updateModel() {
            state.model = document.getElementById('modelInput').value.trim();
            localStorage.setItem('lucicodex_model', state.model);
        }

        // --- History Management ---

        function loadHistory() {
            try {
                const stored = localStorage.getItem(STORAGE_KEY);
                if (stored) {
                    state.history = JSON.parse(stored);
                    updateHistoryUI();
                }
            } catch (e) {
                console.error('Failed to load history', e);
            }
        }

        function saveCurrentSession() {
            if (state.currentMessages.length <= 1) return; // Don't save empty chats

            const title = state.currentMessages.find(m => m.role === 'user')?.content || 'New Chat';
            const shortTitle = title.length > 30 ? title.substring(0, 30) + '...' : title;

            const session = {
                id: state.currentSessionId,
                title: shortTitle,
                timestamp: Date.now(),
                messages: state.currentMessages
            };

            // Update or add
            const idx = state.history.findIndex(s => s.id === session.id);
            if (idx >= 0) {
                state.history[idx] = session;
            } else {
                state.history.unshift(session);
            }

            // Limit history size
            if (state.history.length > 20) state.history.pop();

            localStorage.setItem(STORAGE_KEY, JSON.stringify(state.history));
            updateHistoryUI();
        }

        function loadSession(sessionId) {
            const session = state.history.find(s => s.id === sessionId);
            if (!session) return;

            state.currentSessionId = session.id;
            state.currentMessages = session.messages;

            // Clear UI
            document.getElementById('chatMessages').innerHTML = '';

            // Replay messages
            session.messages.forEach(msg => {
                if (msg.type === 'text') {
                    // Manually add to DOM without pushing to state again
                    const div = document.createElement('div');
                    div.className = `chat-message ${msg.role}`;

                    let avatarHtml = msg.role === 'user' ? 'U' : 'AI';
                    if (msg.role === 'ai') {
                        // For history, we might not know which provider generated it, 
                        // but we'll use the current one or a default AI icon if we tracked it
                        // For now, use current provider's icon for consistency
                        avatarHtml = getProviderIcon(state.provider);
                    }

                    div.innerHTML = `
                <div class="message-avatar ${msg.role}">${avatarHtml}</div>
                <div class="message-content">
                    <div class="message-bubble ${msg.role}">
                        <div class="message-text">${parseMarkdown(msg.content)}</div>
                    </div>
                </div>
            `;
                    document.getElementById('chatMessages').appendChild(div);
                } else if (msg.type === 'code') {
                    // Re-add code block (without approval buttons for history)
                    const div = document.createElement('div');
                    div.className = 'chat-message ai';
                    div.innerHTML = `
                <div class="message-avatar ai">${getProviderIcon(state.provider)}</div>
                <div class="message-content">
                    <div class="message-bubble ai">
                        <div class="code-block">
                            <div class="code-header">SHELL</div>
                            <div class="code-content"><pre>${escapeHtml(msg.content)}</pre></div>
                        </div>
                    </div>
                </div>
            `;
                    document.getElementById('chatMessages').appendChild(div);
                } else if (msg.type === 'result') {
                    // Re-add result
                    const div = document.createElement('div');
                    div.className = 'chat-message ai';
                    const resultClass = msg.isSuccess ? 'result-success' : 'result-error';
                    const title = msg.isSuccess ? '✓ Execution Result' : '✗ Execution Error';
                    div.innerHTML = `
                <div class="message-avatar ai">AI</div>
                <div class="message-content">
                    <div class="message-bubble ai">
                        <div class="result-block ${resultClass}">
                            <div class="result-header">${title}</div>
                            <div class="result-content">${escapeHtml(msg.content)}</div>
                        </div>
                    </div>
                </div>
            `;
                    document.getElementById('chatMessages').appendChild(div);
                }
            });

            scrollToBottom();
            updateHistoryUI();
        }

        function updateHistoryUI() {
            const list = document.getElementById('chatHistory');
            list.innerHTML = '';

            state.history.forEach(session => {
                const li = document.createElement('li');
                li.className = `chat-history-item ${session.id === state.currentSessionId ? 'active' : ''}`;
                li.onclick = () => loadSession(session.id);
                li.innerHTML = `
            <span class="chat-history-item-title">${escapeHtml(session.title)}</span>
            <button class="btn-delete-history" onclick="deleteSession('${session.id}', event)">×</button>
        `;
                list.appendChild(li);
            });
        }

        function deleteSession(sessionId, e) {
            e.stopPropagation();
            if (!confirm('Delete this chat?')) return;

            state.history = state.history.filter(s => s.id !== sessionId);
            localStorage.setItem(STORAGE_KEY, JSON.stringify(state.history));

            if (sessionId === state.currentSessionId) {
                startNewChat(false);
            } else {
                updateHistoryUI();
            }
        }

        function clearAllHistory() {
            if (!confirm('Clear all history?')) return;
            state.history = [];
            localStorage.removeItem(STORAGE_KEY);
            startNewChat(false);
        }

        // --- Utilities ---

        function escapeHtml(text) {
            if (!text) return '';
            return text
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        function parseMarkdown(text) {
            if (!text) return '';
            let html = escapeHtml(text);

            // Bold
            html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');

            // Code
            html = html.replace(/`(.*?)`/g, '<code>$1</code>');

            // Newlines to br
            html = html.replace(/\n/g, '<br>');

            return html;
        }

    </script>

    <%+footer%>